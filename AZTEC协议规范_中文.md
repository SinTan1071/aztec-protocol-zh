# AZTEC 0.1.0

# 介绍

AZTEC是以太坊的连锁隐私协议，可实现高效的零知识交易。我们专注于私人价值转移和资产治理。

### **ERC20令牌的机密表示**

AZTEC协议可以为以太坊上的*任何*通用数字资产启用机密交易，包括*现有*资产。[为了实现AZTEC协议的概念验证](https://etherscan.io/address/0xcf65A4e884373Ad12cd91c8C868F1DE9DA48501F)，我们将一个AZTEC令牌附加到MakerDAO的DAI令牌。这份智能合约可用于将DAI从其公共ERC-20表格转换为机密AZTEC备注表格。

### **完全保密的数字资产**

AZTEC协议可以作为独立的机密令牌使用，价值转移完全通过AZTEC **加入 - 拆分**交易来描述

# 入门

有关AZTEC的代码示例，请转到[快速入门](https://github.com/SinTan1071/aztec-protocol-zh/blob/master)。

要了解有关AZTEC协议的更多详细信息，请访问我们的[技术规范](https://github.com/SinTan1071/aztec-protocol-zh/blob/master)。

有关[AZTEC](https://github.com/SinTan1071/aztec-protocol-zh/blob/master)的概述，有关我们的[Range Proofs的](https://github.com/SinTan1071/aztec-protocol-zh/blob/master)其他[说明](https://github.com/SinTan1071/aztec-protocol-zh/blob/master)和文档，请参阅指南。

# **支持**

请[伸出](https://github.com/SinTan1071/aztec-protocol-zh/blob/master)我们的团队，如果您有关于AZTEC的任何问题，需要帮助开发自己的机密数字资产或想讨论一个整合。我们很乐意帮助！

# 可信设置 - 点火

部署的AZTEC智能合约目前使用由AZTEC内部创建的可信设置，仅应用于测试和开发目的。

在第四季度，我们将运行一个多方计算协议，以创建一个受更广泛的以太坊社区保护的可信设置，其中只有一个人必须诚实地为安全数据库采取行动才能保证安全。如果您想参加，请通过[hello@aztecprotocol.com告知](mailto:hello@aztecprotocol.com)我们

# 包

| [`@aztec/contract-artifacts`](https://github.com/AztecProtocol/AZTEC/blob/develop/packages/contract-artifacts) | [![NPM](https://camo.githubusercontent.com/d922b2c083af868baa4c9fad2e3e2a9fbf1e0da7/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f40617a7465632f636f6e74726163742d6172746966616374732e737667)](https://www.npmjs.com/package/@aztec/contract-artifacts) | AZTEC智能合约编译工件                                    |
| ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------------------------------------- |
| [`@aztec/contract-addresses`](https://github.com/AztecProtocol/AZTEC/blob/develop/packages/contract-addresses) | [![NPM](https://camo.githubusercontent.com/bf762ca95837b808c9bdf2257a2c5eecb8faafd3/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f40617a7465632f636f6e74726163742d6164647265737365732e737667)](https://www.npmjs.com/package/@aztec/contract-addresses) | 一个小型实用程序库，用于获取特定网络的已知已部署合同地址 |
| [`@aztec/dev-utils`](https://github.com/AztecProtocol/AZTEC/blob/develop/packages/dev-utils) | [![NPM](https://camo.githubusercontent.com/f6bdb4baef746fb9237f34fda2b3ad989f60a011/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f40617a7465632f6465762d7574696c732e737667)](https://www.npmjs.com/package/@aztec/dev-utils) | Dev utils可以在AZTEC项目和包中共享                       |

# AZTEC.js

在我们的[AZTEC.js库中](https://aztecprotocol.github.io/AZTEC/)可以找到构建AZTEC零知识证明和创建所需EIP712签名（花笔记）所需的方法。

# 天然气成本

AZTEC交易的天然气成本与**连接拆分**交易中的输入和输出票据数量成比例。对于完全保密的转移，有2个输入票据和2个输出票据，燃气成本约为900,000气体。[计划中的EIP改进](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1108.md)将大大降低这些交易的成本，大约为200,000 - 300,000天然气。

# AZTEC开发者扩展

AZTEC在引擎盖下使用UTXO型号。用户余额由他们拥有的任何给定AZTEC资产的所有UTXO票据的总和组成。每个UTXO音符都有一个唯一的查看键，任何拥有的人都可以使用它来解密UTXO音符值。管理特定用户UTXO注释和相关联的查看键很复杂，并且可能对机密性集产生影响，这可能影响特定用户从AZTEC协议获得的隐私。

为了使开发人员和用户更容易，我们构建了一个管理用户注释和相关查看键的chrome扩展。

此扩展名为**ALPHA**格式，目前仅适用于黑客马拉松项目。我们希望在9月初提供带有UI的完整BETA。

# **入门**

## **第1步 - 安装开发人员扩展**

前往我们的GitHub并在[此处](https://github.com/AztecProtocol/developer-extension)克隆Developer Extension Bundle 。

打开Chrome并导航至**chrome：// extensions。**向右滑动以切换到“开发者模式”，然后单击“加载解压缩”。从文件中选择developer-extension文件夹。扩展程序将自动安装。

[![IMG](https://camo.githubusercontent.com/6a69dd026acbc653e6dc993098a34c701bac2fc6/68747470733a2f2f626c6f627363646e2e676974626f6f6b2e636f6d2f76302f622f676974626f6f6b2d32383432372e61707073706f742e636f6d2f6f2f6173736574732532462d4c685a6a616f636146333459346a5a674769432532462d4c6c3244356e6d376d69637261645961786b5f2532462d4c6c31554835743530485334443262784e523025324653637265656e73686f74253230323031392d30372d3330253230617425323031312e34352e33362e706e673f616c743d6d6564696126746f6b656e3d36336434613335372d656239302d343962322d393735612d343531323930303864343637)](https://camo.githubusercontent.com/6a69dd026acbc653e6dc993098a34c701bac2fc6/68747470733a2f2f626c6f627363646e2e676974626f6f6b2e636f6d2f76302f622f676974626f6f6b2d32383432372e61707073706f742e636f6d2f6f2f6173736574732532462d4c685a6a616f636146333459346a5a674769432532462d4c6c3244356e6d376d69637261645961786b5f2532462d4c6c31554835743530485334443262784e523025324653637265656e73686f74253230323031392d30372d3330253230617425323031312e34352e33362e706e673f616c743d6d6564696126746f6b656e3d36336434613335372d656239302d343962322d393735612d343531323930303864343637)

单击“加载解压缩”以加载扩展源代码。确保您处于开发者模式。

## **第2步 - 设置MetaMask测试帐户**

使用下面的私钥将其中一个测试以太坊帐户导入MetaMask。这个帐户加载了1000个测试ETH，您可以使用它来支付天然气费用。从Network下拉列表中选择LocalHost 8545 Network。

私钥：

```
0xb8a23114e720d45005b608f8741639464a341c32c61920bf341b5cbddae7651d
```

### **第3步 - 与ETH-Global-starter-kit交互**

导航回[localhost：3000](http://localhost:3000/)并在刷新页面后单击“启用AZTEC”按钮。您现在可以发送私人交易了[![🕵️♀️](https://camo.githubusercontent.com/f4a9d94f432bbc359e6a3897aa98b2f0a66afb3b/68747470733a2f2f656d6f6a6970656469612e6f72672f66656d616c652d736c657574682f)](https://camo.githubusercontent.com/f4a9d94f432bbc359e6a3897aa98b2f0a66afb3b/68747470733a2f2f656d6f6a6970656469612e6f72672f66656d616c652d736c657574682f)

**重要的提示**

在此alpha版本中，您必须签署一些MetaMask合同交互才能发送AZTEC交易。在将来的版本中，这些将被抽象化。

扩展名将保留备注数据。如果您重新启动Ganache或需要清除扩展数据，清除扩展程序的最快方法是删除**chrome：// extensions中的扩展程序**，如下所示。只需重新添加扩展即可重新启动。

[![IMG](https://camo.githubusercontent.com/58d59a49312b2e8e44ea317c5ebccee1fbbdd95d/68747470733a2f2f626c6f627363646e2e676974626f6f6b2e636f6d2f76302f622f676974626f6f6b2d32383432372e61707073706f742e636f6d2f6f2f6173736574732532462d4c685a6a616f636146333459346a5a674769432532462d4c6c464c364b5769566b6d30684c31497761422532462d4c6c436364664a61344a4a463878577155375925324653637265656e73686f74253230323031392d30382d3031253230617425323031352e34322e31302e706e673f616c743d6d6564696126746f6b656e3d35326666633233342d656432382d346330312d396437312d323035336462306436323861)](https://camo.githubusercontent.com/58d59a49312b2e8e44ea317c5ebccee1fbbdd95d/68747470733a2f2f626c6f627363646e2e676974626f6f6b2e636f6d2f76302f622f676974626f6f6b2d32383432372e61707073706f742e636f6d2f6f2f6173736574732532462d4c685a6a616f636146333459346a5a674769432532462d4c6c464c364b5769566b6d30684c31497761422532462d4c6c436364664a61344a4a463878577155375925324653637265656e73686f74253230323031392d30382d3031253230617425323031352e34322e31302e706e673f616c743d6d6564696126746f6b656e3d35326666633233342d656432382d346330312d396437312d323035336462306436323861)

安装扩展后，它会将以下对象注入每个页面的窗口：

```
window.aztec = {    enable: async function (options) {}}
```

# **.enable(options)**

此函数采用一个参数选项，可以使用以下键，这些键是可选的，默认为以下值：

```
{    __graphUrl: 'localhost:8020', // change this value if you want to run your own graph node    web3Provider: window.web3.currentProvider, // change this value to use a different web3 provider    contractAddresses: {        ace: '0xFA8eD6F76e8f769872a1f8a89085c56909EC8Cfc', // the address of the ace contract on the local network        aztecAccountRegistry: '0xFA8eD6F76e8f769872a1f8a89085c56909EC8Cfc', // the address of the aztec account registry contract on the local network.        }}
```

此功能将执行以下检查：

1. 在扩展中创建密钥对，用于加密和解密查看密钥
2. 将密钥对存储在扩展中的加密密钥保险库中，并使用用户密码进行加密。
3. 确保密钥对的加密公钥已通过AZTECAccountRegistry.sol合同链接到链上的以太坊地址。

该函数返回一个promise，如果所有检查都通过，它将解析为完整的AZTEC api。

## **注册扩展**

当第一次调用window.aztec.enable时会发生两件事：

web3提供程序将请求在页面上启用批准。如果您使用的是MetaMask（推荐），则会显示如下弹出窗口：

[![IMG](https://camo.githubusercontent.com/0dd73569dd3474fd894ef18adf409906debb4248/68747470733a2f2f626c6f627363646e2e676974626f6f6b2e636f6d2f76302f622f676974626f6f6b2d32383432372e61707073706f742e636f6d2f6f2f6173736574732532462d4c685a6a616f636146333459346a5a674769432532462d4c6c426d4e787a347a5f336a50546b2d76615f2532462d4c6c426a795a445567425f54437370356e676e25324653637265656e73686f74253230323031392d30382d3031253230617425323031312e33332e33332e706e673f616c743d6d6564696126746f6b656e3d33646664363261642d303863312d343633632d623162342d653761626536613435646136)](https://camo.githubusercontent.com/0dd73569dd3474fd894ef18adf409906debb4248/68747470733a2f2f626c6f627363646e2e676974626f6f6b2e636f6d2f76302f622f676974626f6f6b2d32383432372e61707073706f742e636f6d2f6f2f6173736574732532462d4c685a6a616f636146333459346a5a674769432532462d4c6c426d4e787a347a5f336a50546b2d76615f2532462d4c6c426a795a445567425f54437370356e676e25324653637265656e73686f74253230323031392d30382d3031253230617425323031312e33332e33332e706e673f616c743d6d6564696126746f6b656e3d33646664363261642d303863312d343633632d623162342d653761626536613435646136)

点击后，AZTEC Extension将打开一个窗口，要求用户注册扩展名：

[![IMG](https://camo.githubusercontent.com/f8c43ea922e7e370df1ff3f59422c55dfdc0959c/68747470733a2f2f626c6f627363646e2e676974626f6f6b2e636f6d2f76302f622f676974626f6f6b2d32383432372e61707073706f742e636f6d2f6f2f6173736574732532462d4c685a6a616f636146333459346a5a674769432532462d4c6c426d4e787a347a5f336a50546b2d76615f2532462d4c6c426b4361525f4f457a79386f6d42725a5125324653637265656e73686f74253230323031392d30382d3031253230617425323031312e33312e33342e706e673f616c743d6d6564696126746f6b656e3d30313938663735332d303761322d343030332d383139342d633135373133346637623530)](https://camo.githubusercontent.com/f8c43ea922e7e370df1ff3f59422c55dfdc0959c/68747470733a2f2f626c6f627363646e2e676974626f6f6b2e636f6d2f76302f622f676974626f6f6b2d32383432372e61707073706f742e636f6d2f6f2f6173736574732532462d4c685a6a616f636146333459346a5a674769432532462d4c6c426d4e787a347a5f336a50546b2d76615f2532462d4c6c426b4361525f4f457a79386f6d42725a5125324653637265656e73686f74253230323031392d30382d3031253230617425323031312e33312e33342e706e673f616c743d6d6564696126746f6b656e3d30313938663735332d303761322d343030332d383139342d633135373133346637623530)

用户可以恢复现有密钥集或注册新集。

[![IMG](https://camo.githubusercontent.com/206095a7832c8f20dc76ef28170208410b1066fb/68747470733a2f2f626c6f627363646e2e676974626f6f6b2e636f6d2f76302f622f676974626f6f6b2d32383432372e61707073706f742e636f6d2f6f2f6173736574732532462d4c685a6a616f636146333459346a5a674769432532462d4c6c426d4e787a347a5f336a50546b2d76615f2532462d4c6c426c313966724249705f3955384c4f4a4725324653637265656e73686f74253230323031392d30382d3031253230617425323031312e33372e34312e706e673f616c743d6d6564696126746f6b656e3d62316634363735302d366266382d343366352d386238392d633338333265363639633733)](https://camo.githubusercontent.com/206095a7832c8f20dc76ef28170208410b1066fb/68747470733a2f2f626c6f627363646e2e676974626f6f6b2e636f6d2f76302f622f676974626f6f6b2d32383432372e61707073706f742e636f6d2f6f2f6173736574732532462d4c685a6a616f636146333459346a5a674769432532462d4c6c426d4e787a347a5f336a50546b2d76615f2532462d4c6c426c313966724249705f3955384c4f4a4725324653637265656e73686f74253230323031392d30382d3031253230617425323031312e33372e34312e706e673f616c743d6d6564696126746f6b656e3d62316634363735302d366266382d343366352d386238392d633338333265363639633733)

[![IMG](https://camo.githubusercontent.com/8886e6cd5bd123d76843596132a6f85b57ecb0e1/68747470733a2f2f626c6f627363646e2e676974626f6f6b2e636f6d2f76302f622f676974626f6f6b2d32383432372e61707073706f742e636f6d2f6f2f6173736574732532462d4c685a6a616f636146333459346a5a674769432532462d4c6c426d4e787a347a5f336a50546b2d76615f2532462d4c6c426c33464b76796a6a356f304e5537544725324653637265656e73686f74253230323031392d30382d3031253230617425323031312e33372e34372e706e673f616c743d6d6564696126746f6b656e3d33376532656565642d633536662d343337302d613433332d666236656635346563663866)](https://camo.githubusercontent.com/8886e6cd5bd123d76843596132a6f85b57ecb0e1/68747470733a2f2f626c6f627363646e2e676974626f6f6b2e636f6d2f76302f622f676974626f6f6b2d32383432372e61707073706f742e636f6d2f6f2f6173736574732532462d4c685a6a616f636146333459346a5a674769432532462d4c6c426d4e787a347a5f336a50546b2d76615f2532462d4c6c426c33464b76796a6a356f304e5537544725324653637265656e73686f74253230323031392d30382d3031253230617425323031312e33372e34372e706e673f616c743d6d6564696126746f6b656e3d33376532656565642d633536662d343337302d613433332d666236656635346563663866)

# **.asset**

```
const asset = await window.aztec.asset('0x3339C3c842732F4DAaCf12aed335661cf4eab66b');
```

资产方法用于获取有关ZkAsset的信息，并返回一组依赖于存储的UTXO注释和查看扩展内部键的方法。

如果页面尚未请求访问用户余额，则扩展程序将打开一个弹出窗口，要求用户授予域以访问资产余额并允许扩展程序为此资产构建校样。

[![IMG](https://camo.githubusercontent.com/bfbcdec4623b47b291861f8b493d0208308465c6/68747470733a2f2f626c6f627363646e2e676974626f6f6b2e636f6d2f76302f622f676974626f6f6b2d32383432372e61707073706f742e636f6d2f6f2f6173736574732532462d4c685a6a616f636146333459346a5a674769432532462d4c6c376959504e5350306969433773687957702532462d4c6c376a75516848676532413632646c41717925324653637265656e73686f74253230323031392d30372d3331253230617425323031362e35362e33382e706e673f616c743d6d6564696126746f6b656e3d30346138323665392d623333622d343661382d613833362d643962303864663035616130)](https://camo.githubusercontent.com/bfbcdec4623b47b291861f8b493d0208308465c6/68747470733a2f2f626c6f627363646e2e676974626f6f6b2e636f6d2f76302f622f676974626f6f6b2d32383432372e61707073706f742e636f6d2f6f2f6173736574732532462d4c685a6a616f636146333459346a5a674769432532462d4c6c376959504e5350306969433773687957702532462d4c6c376a75516848676532413632646c41717925324653637265656e73686f74253230323031392d30372d3331253230617425323031362e35362e33382e706e673f616c743d6d6564696126746f6b656e3d30346138323665392d623333622d343661382d613833362d643962303864663035616130)

一旦授予此类，将在`asset`课程中提供以下方法。

## **async asset.balance()**

返回一个promise，该promise将解析为表示资产余额的整数。

## **async asset.deposit(amount)**

此方法用于将ERC20标记转换 `linkedTokenAddress`为AZTEC注释形式。它使用以下方法返回证明类

```
const proof = asset.deposit(50);await proof.approve() // calls the necessary ERC20 approvals to permit ACE to spend public tokensawait proof.send() // sends the proof to the blockchain for validation await proof.export() // exports the proofdata for sending later
```

## **async asset.withdraw()**

此方法用于将AZTEC音符转换为ERC20的令牌 `linkedTokenAddress`

## **async .send({amount: 50, to})**

此方法用于将AZTEC注释发送给另一个所有者。

```
const tx = {    amount: 50,    to: '0x3339C3c842732F4DAaCf12aed335661cf4eab66b'};
```

## **async .createNoteFromBalance(amount)**

此方法用于创建特定的AZTEC注释，以用于其中一个校样。

它将返回一个连接拆分证据，可以将其发送到区块链以创建结果注释。

## **async .refresh()**

此方法用于将资产的余额刷新到最新的索引版本。

# **async .note(noteHash)**

如果请求此域的域可以访问ZkAsset

## **async .grantNoteAccess(address)**

此方法授予对注释的传入地址访问权限。如果另一方需要在证明中使用该注释，则需要这样做。例如`PrivateRange`证明或`Swap`证明。

此方法将触发MetaMask事务，因为notes meta ata需要更新并在链上进行广播。

## **.value**

这是一个静态整数，表示如果用户有权访问该注释的值。

## **.hash**

这是一个包含注释哈希的静态字符串。

## **.owner**

这是`string`包含备注所有者的以太坊地址的静态。

# **与AZTEC.js方法一起使用**

该库与下面的7个aztec样张兼容`window.aztec.proofs`。这是`PrivateRange`，`PublicRange`，`JoinSplit`，`BilateralSwap`，`Mint`和`Burn`

扩展API采用alpha格式，API未完全实现。实现的最有用的功能是扩展程序能够跟踪用户余额和查看密钥，然后通过该`createNoteFromBalance`方法从用户现有余额创建新笔记。

**重要笔记：**

发送导致票据被销毁的任何转移指令首先必须得到票据所有者的批准才能使用该票据。这适用于扩展API的Send，Burn，Swap，CreateNoteFromBalance方法。

```
ZkAsset.confidentialApprove(spender, status, eip712signature)
```

该`eip712signature` 如果音符所有者是可以省略`msg.sender.`

# 贷款dApp入门套件

您可以使用AZTEC构建的示例

贷款[dApp](https://github.com/AztecProtocol/loan-dapp-starter-kit)和随附的Medium文章是开始使用AZTEC的最快方式。

1. [AZTEC简介](https://medium.com/aztec-protocol/an-introduction-to-aztec-47c70e875dc7)
2. [将AZTEC部署到Ganache](https://medium.com/aztec-protocol/deploying-aztec-to-ganache-dc02d538b24f)
3. [构建证明，签名流程和密钥管理](https://medium.com/aztec-protocol/constructing-proofs-signing-flows-and-key-management-6fceb99b2951)
4. [创建，结算和流式传输机密资产](https://medium.com/aztec-protocol/creating-settling-streaming-confidential-assets-256d09e4c8c5)

# 将AZTEC部署到Ganache

对于大多数dApp构建者而言，部署到Ganache对于测试与AZTEC的智能合约交互至关重要。

要开始使用，请在[此处查看](https://github.com/AztecProtocol/aztec-ganache-starter-kit) AZTEC [github](https://github.com/AztecProtocol/aztec-ganache-starter-kit)上的入门套件[。](https://github.com/AztecProtocol/aztec-ganache-starter-kit)该工具包包含将AZTEC部署到本地区块链所需的迁移以及示例流程。将AZTEC部署到以太坊的私有分支时，此流程是相同的。

1. 克隆存储库 `git clone git@github.com:AztecProtocol/aztec-ganache-starter-kit.git`
2. 安装依赖项 `cd aztec-ganache-starter-kit && yarn install`
3. 重命名`.env`文件`mv RENAME_ME.env .env`
4. 启动Ganache `yarn start`（这将从凭据创建5个测试以太坊帐户`.env`）
5. 部署AZTEC！ `yarn migrate`

如果您想了解所需的迁移及其操作，请阅读[此处](https://medium.com/aztec-protocol/deploying-aztec-to-ganache-dc02d538b24f)的完整文章。

# AZTEC介绍

# **为什么AZTEC存在**

区块链的一个被广泛使用的用途包含在“ *可编程货币* ” 这一短语中- 一种控制金融应用程序内资本流动的智能合约。*例如，只有当买方的总持仓量低于4％的监管限额时，才会进行债券转移。*如果能够实现这一目标，可以在公共区块链之上重建大量金融系统，并在此过程中删除中介，结束对账并删除对方风险。今天使用以太坊区块链，可以直接创建“ *可编程货币* ”。但是有一个问题 -  **隐私**。

> 任何区块链交易的输入和输出都在事务有效负载内公开广播。

在债券转移示例中，必须广播交易名义和交易者当前头寸，以便智能合约验证交易符合4％监管限制。对于真实世界的金融应用程序而言，这是一个非首选，其中交易隐私是***先决条件***。

### **创建\* AZTEC协议\*是为了实现公共区块链的隐私。它允许对加密值执行逻辑检查，而不会将基础值显示给区块链。事务的输入和输出使用一系列零知识证明和同态加密进行加密，但区块链仍然可以测试这些加密语句的逻辑正确性。**

# ****引擎盖下\****

在以太坊上验证传统的零知识系统是行不通的。这是由于链上验证气体成本，慢速证明构造以及资产之间缺乏互操作性的结合。缺乏互操作性和无法在客户端浏览器上运行证明构建使得这些系统不适合在现实世界的金融应用程序中使用。零知识系统中最大的成本之一是范围证明。一个***范围的证明***允许证明者向验证者证明数字在特定范围内。在处理椭圆曲线点的加法时，这是至关重要的。在椭圆曲线上，负数实际上是一个非常大的正数，范围证明用于确保任何点都在可用范围内，并通过绕模数来防止双重花费攻击。AZTEC的范围证明采用可靠的设置，大大降低了检查的成本。

一旦证明加密数字在可用范围内，椭圆曲线的附加属性允许对其执行逻辑检查。这种称为***同态加密的***概念允许对加密数字执行逻辑检查，就好像它们没有被加密一样。即，可以像在公共交易中那样执行相同的检查，但是不会泄露加密数字的基础值。

这两种加密方法组合成一组sigma协议，允许在链上验证特定的逻辑语句。如果您想了解有关协议的加密技术的更多信息，请阅读[**白皮书**](https://github.com/AztecProtocol/AZTEC/blob/develop/AZTEC.pdf)**。**

# **** AZTEC的心理模型\****

AZTEC遵循类似于比特币的UTXO模型。任何AZTEC交易的核心都是***注释。***对于任何给定的资产，票据的状态由***Note Registry***管理。

> 用户在任何AZTEC资产中的余额由其地址在给定的***注释注册表中***拥有的所有有效注释的总和组成。

[![IMG](https://camo.githubusercontent.com/beb234b2fae0c585eec52fdf3e0974b3a65f33ed/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f312a55366a554d6b4d5f3632537038424d41306a786d6f512e706e67)](https://camo.githubusercontent.com/beb234b2fae0c585eec52fdf3e0974b3a65f33ed/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f312a55366a554d6b4d5f3632537038424d41306a786d6f512e706e67)

AZTEC的UTXO型号

公共区块链提供两个主要好处，围绕国家的正确性和资本的互操作性提供独立的经济保障。（作为贷款利息支付而收到的资本也可用于结算不同资产的交易）。大多数零知识系统缺乏这种互操作性。他们创造了孤立的私人资本池。AZTEC旨在解决这个问题。它允许在零知识中交互的dApp之间的互操作性。

为实现这种互操作性，所有AZTEC资产共享一个共同的可信设置，其状态由单个智能合约AZTEC加密引擎或ACE管理。ACE有两个主要功能; 首先将证明的验证委托给特定的验证合同，然后再处理由成功验证的证据产生的注释注册表中的状态更新指令.AZTEC Architecture

[![IMG](https://camo.githubusercontent.com/717d76baed0eeb64c875fc2be5829fb7a7c68212/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f312a6b42517547307a37426e64316f464b2d74436f5470412e706e67)](https://camo.githubusercontent.com/717d76baed0eeb64c875fc2be5829fb7a7c68212/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f312a6b42517547307a37426e64316f464b2d74436f5470412e706e67)

# ****一组构建基块，以实现隐私\****

AZTEC协议旨在为dApp构建器提供一组模块化构建块，每个构建块都支持特定的功能。开发人员可以将这些构建块组合在一起以构建私有dApp，而无需加密人。在这些工具包中，这些工具包是Sigma协议，可以证明所提供的输入和输出注释之间的关系。目前AZTEC支持其中7个工具包：

**加入Split（转会）**

Join Split证明允许将一组输入音符连接或拆分为一组输出音符。通常，这用于将音符值组合成更大的音符，或者将音符拆分为具有不同所有者的多个音符。此证明确保输入音符的总和等于输出音符的总和。

Join Split事务还有两种变体，用于处理公共ERC20值。其中公共ERC20值转换为AZTEC注释并且是互惠的，其中AZTEC注释被转换为公共ERC20值。

**双边互换（贸易）**

双边交换证明允许进行两个笔记的原子交换。这对于交易两种资产非常有用，*例如法定货币和贷款/债券/证券*。经过验证的证明证明，制造商的投标票据等于拍卖者要求票据，而制造商要求票据等于拍卖者的投标票据。

**股息证明**

该证明允许证明者证明输入音符等于输出音符乘以比率。这对于从资产中支付利息很有用。

**薄荷**

薄荷证明可以让受信任的一方提供AZTEC笔记。*例如，稳定的硬币将AZTEC票据与其收到的银行转账的价值相等。*

**烧伤**

耐燃可以让受信任的一方减少供应AZTEC钞票。*例如，稳定的硬币燃烧AZTEC票据，该票据与发送给票据所有者的银行转账价值相等。*

**私人牧场**

这用于证明AZTEC音符大于另一个AZTEC音符，反之亦然。这有助于证明交易后资产的所有权低于监管最大值。它还可用于构建身份和组成员身份方案。

**公共** **范围**

类似于私人范围证明。这用于证明AZTEC音符大于公共整数，反之亦然。这有助于证明交易后资产的所有权低于监管最大值。

# ****隐私，匿名和保密\****

在讨论零知识系统时经常使用这些术语。定义每个的含义并解决AZTEC如何处理它们非常重要。

***隐私：*** *交易的所有方面都隐藏在公众或第三方之外。*

***保密性：*** *交易的输入和输出对公众是隐藏的，但交易方仍然是公开的。*

***匿名：*** *交易的输入和输出是公开的，但交易图从一个交易模糊到下一个交易，阻止了交易方的识别。*

**AZTEC可实现开箱即用的保密交易**。任何交易的输入和输出都表示为加密数字，并且隐藏在公共视图中的值。

使用普通的以太坊地址，AZTEC的交易图不是匿名的。但是匿名交易是可能的。该协议是前向兼容的隐形地址，并且由于AZTEC不要求交易发送方成为交易中的一方，因此可以隐藏交易图。将隐形地址与受信任方结合以进行中继交易可实现完全匿名。使用受信任的第三方隐藏燃气费并提供完全匿名。该协议的未来更新将允许交易中继，同时模糊分散庄园中的天然气支付。那时**完全私人交易**是可能的。

# ****创建机密资产\****

[EIP1724](https://github.com/ethereum/EIPs/issues/1724)旨在标准化界面，以便与符合基于UTXO的模型的机密资产进行交互。AZTEC针对`@aztec/protocol`NPM包中支持的资产类型提供了EIP1724的参考实现。

[![IMG](https://camo.githubusercontent.com/20a053ea9dcbf477c0c43e1cdd58da82827381e9/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f312a51654256774759746a734368334b674247716a7941772e706e67)](https://camo.githubusercontent.com/20a053ea9dcbf477c0c43e1cdd58da82827381e9/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f312a51654256774759746a734368334b674247716a7941772e706e67)

EIP 1724 ZkAsset标准

我们来看一个例子：

想象一下，有问题的dApp需要进行逻辑检查，以确保交易者的交易后资产余额低于监管最大值。

在普通的dApp中，此检查很容易执行。交易输入将包含公共变量`tradeNotional.`然后合同可以执行简单的检查，确保新`assetBalance[buyer]`的低于`regulatoryMax`。

```
if(regulatoryMax > tradeNotional + assetBalance[buyer]) { // the trade can proceed}
```

在私有AZTEC dApp中，可以使用AZTEC证明之一执行相同的逻辑检查。心理模型略有不同，因为所有变量都存储为加密的AZTEC注释，然后构建证明，如果由ACE验证，则确保所需的逻辑语句是正确的。

```
const {   proofData,} = await aztec.proof.privateRange.encodePrivateRangeTransaction({    originalNote: regulatoryMax,    comparisonNote: postTradeUserBalance,    senderAddress: accounts[0],  });
```

这个证明证明了`comparisonNote`小于`originalNote`。如果值被交换，则证明相反。一旦证明构建完毕，它就可以转发给ACE进行验证。

```
(bytes memory _proofOutputs) = ACE.validateProof(                                 PRIVATE_RANGE_PROOF,                                 address(this),                                 _proofData                               );
// if the above statement succeeds we know that the users post trade balance is below the regulatory minimum.
```

AZTEC旨在允许这些逻辑检查的组合来构建财务dApp所需的复杂流程。

# 以太坊的机密交易

交易隐私是许多种金融服务的基本要求，无法提供这种隐私，使得以太坊无法提供引人注目的传统金融工具替代品。有几个区块链和区块链项目使用加密技术来提供这种隐私，但是这个隐私是为所讨论的区块链的“本地”加密货币保留的。对于构建在区块链协议之上的数字资产，无法访问此交易隐私。例如，我无法在以太坊上编制企业债券智能合约，其中所有权概念是私有的。

好吧，直到现在，就是这样。

### ****显示和告诉：机密DAI \*的特殊情况***

在这里，看看这个：

```
{    "gamma": "0x20a92d2a4f0dd850314a745719dde20934db69cc8e9b5b84b5819e062d66bb7500",    "sigma": "0x17d62693c0c9a356e2fd6b0ce877b78c6a1f8a7f195e9db4c0b68e0693d73b3600"}
```

这种奇特的混乱角色是DAI的一种形式，由MakerDAO创造的美元挂钩稳定币。但它看起来*有点奇怪*，不是吗？这通常只是一个以太坊地址，以及一个数字，表示以太坊地址有多少DAI。但这不是正常的DAI。

你看，当我发送[这个交易时](https://etherscan.io/tx/0xf9a101682c637f7741f281c858527d17036f4df284b7064bd1ca44531ab88374)，我的以太坊地址（zac.creditmint.eth）成了这个DAI的所有者，但事情就是这样：没人能弄清楚我有多少DAI。与世界上几乎所有其他DAI持有者不同，我的DAI余额是*加密的，*并以零知识AZTEC笔记的形式表示。我可以通过发送一些到不同的地址来随意使用这个DAI，但是当我这样做时，没有人能够弄清楚我发送了多少。例如，我送一个同事我的一些DAI在[本次交易](https://etherscan.io/tx/0xf9a101682c637f7741f281c858527d17036f4df284b7064bd1ca44531ab88374)和*好运气*搞清楚他们有多少。

这一切都很新，我*很*高兴能向你和更广泛的以太坊社区展示这一点。我们已经开发了近一年了，但是我们还没有做出任何正式的公告，因为我想告诉你那些特殊的，奇特的，混乱的十六进制字符。

因为这不是一个想象的技术，将在一天内实施。

它不需要修改以太坊协议。

今天是在以太坊主网上现场直播的工作演示*，*并且AZTEC零知识笔记是加密真实DAI的真实笔记。

# **** AZTEC机密交易明细\****

这里有两个问题：*什么*是AZTEC协议以及它是*如何*工作的？我只能回答*如何*通过进入椭圆曲线密码，这是另一个博客一篇文章的主题的胆量（你可以阅读我们的正式描述[文件](https://github.com/AztecProtocol/AZTEC/blob/master/AZTEC.pdf)对于这件事情是如何工作的闪电总结：这不是一个ZK-SNARK ，这是一个代数零知识证明，利用Boneh-Boyen签名创建一个承诺方案，并在每个承诺中嵌入高效的范围证明。

是的，好吧那就清除了一切。所以我将专注于回答*什么*的AZTEC协议。交易发送到它*时*它*在做*什么？首先，我们需要描述“保密交易”的含义。

机密交易是两个或更多实体之间的*价值*转移，其中被转移的*价值*对观察者不可见。

机密交易有多种形式，从环签名到ZK-SNARK电路。与ZCash类似，AZTEC协议使用加密'notes'和join-split事务的概念。

# ****加密数字资产和AZTEC注\****

AZTEC协议并不代表传统余额的“价值”，它将所有者映射到他们拥有的数量。相反，价值由**笔记**表示。注释包含以下**公共**信息：

- AZTEC承诺：加密表示该注释的“价值”
- 音符所有者的以太坊地址

注释具有以下**私人**信息

- 笔记的价值
- 音符的***查看键*** *。* ***查看键的***知识使人能够解密音符（但不会花费）

一个所有者可以有多个笔记。符合AZTEC协议的数字资产将包含**注释注册表**，该**注册表**允许智能合约恢复当前存在的每个**未花费的**注释的公共信息。

# ****如何使用AZTEC笔记？\****

AZTEC票据所有者可以在连接拆分式保密交易中“支出”他们的票据。在此交易中，票据所有者将销毁他们拥有的一些未使用的AZTEC票据。在他们的位置，他们将创建一组新笔记。新笔记的*值*的总和必须等于旧笔记的*值*的总和，加上*公共*承诺（我稍后会对此进行说明，但是现在让我们假设它值为0）。

所以想象一下，爱丽丝有两张价值100令牌的AZTEC笔记。如果她想发送Bob 20令牌，Alice会创建Bob拥有的一个或多个备注，其值总和为20.然后她将创建一个或多个由她拥有的备注，其总和为80个令牌。

然后，她将创建一个AZTEC零知识证明，证明这种关系在零知识中（即Alice不向任何人透露这些笔记实际上有多少价值，只是平衡关系成立）。然后，AZTEC令牌智能合约将验证此零知识证明，销毁Alice的输入注释，然后在其注释注册表中创建输出注释。

当Alice创建Bob的笔记时，她通过非交互式秘密共享协议构建了Bob能够识别的笔记查看密钥。Bob依赖于Alice在这方面“信任”，并且不提供可由观察者解码的查看键。这已经是隐含的要求了 - 毕竟，如果她不希望交易保密，爱丽丝可以向世界广播她向Bob发送了多少。

## ****如何定义'所有权'？\****

每个机密交易还需要数字签名 - 每个输入票据都需要签名，由输入票据的所有者签名。签名的消息是零知识证明的散列。这隐含地接受了票据所有者对机密交易的结果感到满意，并希望处理交易。

## ****我们如何获得AZTEC注释表的价值？\****

保密地转移价值是很好的，但是没有办法获得“价值”（让我们称之为***v***）进入AZTEC密码系统，这一切看起来都有点学术性。这是通过机密交易中的“公开承诺”来完成的。假设AZTEC令牌链接到公共ERC-20令牌。如果AZTEC零知识证明需要公共承诺值***v！= 0***才能使平衡方程正确，这意味着以下两点之一：

\ 1。如果***v***为负，输出音符都值得***-v***超过输入音符

\ 2。如果***v***为正时，输入音符都值得***v***超过输出笔记

如果Alice发布***v***为否定的机密交易，则AZTEC令牌智能合约将从Alice 转移***-v***公共ERC-20令牌到其自己的合同地址。实际上，AZTEC令牌智能合约是ERC-20令牌的保管人，同时它们是保密票据形式。当然，如果拒绝此令牌传输（例如，Alice没有足够的令牌），则交易将被中止。

如果Alice发布***v***为正的机密交易，则表示从AZTEC票据转换为公共ERC-20令牌。AZTEC令牌智能合约将转移Alice ***v*** public ERC-20令牌。

有一个小警告 - 转移的令牌数量实际上是***v***乘以比例因子。这是因为AZTEC笔记支持的整数范围小于ERC-20标记的整数范围。我们对main-net的概念验证支持从0到大约100万的数字，我们对AZTEC协议的全面实现将支持大约32位整数（稍微多一点）。另一方面，ERC-20令牌余额由256位整数表示。

选择的缩放因子取决于链接到的ERC-20令牌。对于我们的概念证明机密DAI部署，值为***1***的AZTEC注释等于***0.1*** DAI。

# ****所有这些费用是多少？\****

AZTEC协议使用定制的承诺方案，可实现高效的范围证明。结果，验证智能合约所需的计算量远小于预期。机密交易的天然气成本的压倒性贡献者是验证AZTEC零知识证明所需的椭圆曲线算法。它需要`3i + 4j` *椭圆曲线标量乘法*来验证证明，其中*i*是输入音符的数量，*j*是输出音符的数量。每个`confidentialTransfer`事务还需要单个椭圆曲线双线性比较来验证。

我使用这种奇怪措辞的原因是因为由于geth和奇偶校验（[EIP-1108](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1108.md)）实施的协议升级，这些算术运算的气体成本将来可能会下降。它目前花费大约[900,000 **气体**](https://etherscan.io/tx/0x6cb6bccb6d51445ce026dd76b8526e8014a6a276255d22e4f5be26f8efb891fb)来发行包含4个钞票的机密交易（这是*总*燃气成本，而不仅仅是验证交易密码的成本）。如果/当EIP-1108上线时，天然气成本将降至约200,000-300,000。

# ****可以从机密交易中收集哪些信息？\****

在过去的11个月里，AZTEC协议一直是我的一个难题，如果不充分考虑协议的优势和局限性，我不会觉得这很容易发布，我相信这是关于这一点的。很重要

除此之外，任何将公共内容转换为私有内容的协议都会在密码系统的入口和出口点显示信息。

如果您将标记添加到注释表单中，则观察者将知道输出注释的值*至少*是您转换的数量。

同样，赎回后***v***令牌，观察者就会知道，剩下的AZTEC音符都值得***v***低于输入笔记。

通过将公共转换与其他AZTEC笔记相结合，可以改善这些问题。例如，假设Bob有一张价值***100***令牌的笔记，他想将其转换为公共令牌形式。Bob不应该只发出转换，而应在其事务中添加额外的输入注释，并生成一些输出注释，即使额外的输入和输出注释值为***0***。这将阻止观察者弄清楚他已经转换了多少鲍勃的机密资产，即使他已经转换了所有这些，并留下了一堆没有价值的笔记。

AZTEC笔记由以太坊地址定义的“所有者”。从表面上看，注意所有权不是匿名的（例如，人们可以看到[我的以太坊地址](https://etherscan.io/address/0xa9b16b8c2399510706cd275ad9f86ef668067351)具有零知识DAI注释）; AZTEC协议包括一个Monero风格的秘密地址协议，用于派生以太网地址，这些地址是一次性的，不能链接到任何其他以太坊地址（例如，如果你有一个AZTEC钱包，我可以'给以太坊地址'发送'一个注释你控制，但除了你和我之外没有人知道这是事实。该协议支持隐身地址（需要特定钱包才能工作;你需要两个公钥/私钥对，因此常规的以太坊帐户不起作用）和常规的以太坊地址（不是匿名的 - 如果你拥有一个注释，每个人都会能够看到）。

双重公共/机密资产的用户越多，提供的隐私就越大。例如，在测试我们的主网部署时，我将***50*** DAI转换为AZTEC笔记并向我的同事发送了一堆。显然，所有音符的总和是***50*** DAI，所以单个音符不能加密很多。现在想象一下其他人创造了***1000*** DAI的机密笔记，我们拆分并合并了一些笔记 - 除了他们将***1050*** DAI作为最大值之外，不可能确定这些笔记中有多少DAI 。

为了将其降低到极端 - 如果我将***10*** DAI转换为单个AZTEC注释，则根本不提供隐私。创建价值*为零的*音符的能力对于最大限度地提高隐私非常重要 - 如果您要转换***10*** DAI并希望单个音符易于使用，您还应该创建一些价值***0*** DAI的音符来掩盖每个音符的大小。价值。

当然，协议的“懒惰”使用会泄漏信息。例如，假设您将***10*** DAI转换为5个音符，其中4个值为***0*** DAI。如果你后来忘记了这些笔记并且从未在未来的交易中使用它们，那么对于观察者而言，未使用的笔记一无所获将是相当明显的。始终在join-split事务中发布零值注释，并在将来的join-split事务中使用它们可以最大限度地减少外部观察者可用的信息量。

# **** AZTEC协议的可靠设置\****

AZTEC协议高效的原因是我们将Boneh-Boyen签名和Pedersen风格的承诺结合到一个承诺方案中，并在承诺中嵌入了高效的范围证明。这需要在使用AZTEC协议之前生成椭圆曲线点数据库。此数据库是*构建*校样所必需的，但不需要*验证*它们。

有点像ZCash，这个可信任的设置会生成“有毒浪费” **私钥**，如果泄露了该私钥的知识，它可以用于有效地进行双重花费，并且协议变得无法使用。

那我们该怎么处理呢？好吧，对于我们，我们不仅仅指望您*信任*我们。我们开发了可扩展的多方计算协议，使任何人都可以参与可信的设置过程。如果你参与，你会产生一块“有毒废物”，当然应该被销毁。可信任的设置**私钥**，必须不惜一切代价销毁的东西，只能通过拼凑*每个参与者的*有毒废物来恢复。所以如果*单身* 老实说，这个方案是完全安全的，并且只能通过解决其中一个离散的对数问题（其中椭圆曲线密码学的全部存在;如果有人破解了离散的对数问题，我们都遇到了更大的问题）来“破解”在我们手上而不是AZTEC协议的安全性！）。

我们将在未来几个月内宣布我们可信赖的设置流程的正式描述，并将开始收集参与者。它类似于ZCash的“tau的权力”仪式，尽管AZTEC协议不是ZK-SNARK，但结果却截然不同。我们希望可信赖的设置协议很容易参与，我们希望在此过程中与更广泛的以太坊社区互动，以创建一个值得社区信任和信任的可信设置数据库。

我们部署的概念验证智能合约使用内部生成的可信设置，因为实施我们的多方计算可信设置将需要几个月的时间。在我们完成这个阶段之前，AZTEC协议非常依赖于您自己的风险。虽然我*自然地*摧毁了有毒废物，但没有办法证明我这样做了。

最后一点（zing ......）。可信设置数据库的大小随协议范围证明的大小线性增长。我们的概念验证数据库支持0到1,048,575之间的整数，因为我想要一个小到足以容纳github仓库的数据库，而不需要下载。我们的完整实现将支持更大范围的整数。

# ****为什么AZTEC协议很重要？\****

当然，*我*会说这很重要，我是你在这个话题上最有偏见的人！但这就是为什么我认为这是一个真正的游戏规则改变者：AZTEC协议可以创建*通用的*机密数字资产。我们选择DAI开始，但只需按一下按钮，AZTEC协议就可以应用于*任何* ERC-20令牌。它还使构建*纯粹机密*没有任何ERC-20令牌等价物的资产。无需额外的加密电路，无需额外的可信设置过程。有史以来第一次，可以在以太坊上创建机密的数字资产，在不牺牲隐私的情况下获得公共区块链的不变性和分散化优势。

AZTEC零知识证明也非常有效地*构建*，并且完全在硬件钱包的能力范围内。这开启了直接从硬件钱包发布机密交易并且从不暴露敏感私钥的令人兴奋的可能性。

# **** AZTEC协议的未来是什么？\****

与此相关的是发布我们的AZTEC证明构造API，以配合[我们的智能合约验证器和技术论文](https://github.com/AZTECProtocol/AZTEC)。我们还在工作中对AZTEC协议进行了多次扩展，并将在2019年上半年发布我们对AZTEC协议的全部愿景。这包括几个重要的里程碑：

\ 1。一个机密的分散交易所，人们可以完全保密地交易不同的AZTEC资产 - 订单的数量或价格都不能从已处理的订单中收集。分散交换使用继电器模式来实现这一点，以及定制的AZTEC DeX零知识证明（实际上，三个，一旦我们的DeX论文最终确定，我将深入讨论这个问题）。

\ 2。保密加权投票。尊重用户投票隐私的治理机制对于大量金融应用至关重要，而AZTEC协议的有效范围证明使其成为可能。

\ 3。匿名身份共享方案。能够证明你是一个组的一部分，没有透露*谁*，你是该组中是许多遵从和KYC流程，我们的AZTEC令牌标准将支持这种识别系统的重要组成部分。

结合在一起，这将为建筑商提供创建下一波分散金融服务所需的工具; 具有*隐性*隐私和机密治理机制的数字资产从头开始构建。

# 范围证明

本文深入探讨了AZTEC协议如何实现高效的机密交易。

但在我开始之前，我有一个忏悔。

你看，我在解释加密时遇到了问题。它通常非常令人困惑和不直观 - 证明您了解数据之间关系而不必共享数据的*做法*。这有点奇怪，难以解释。

这个问题不是我独自挣扎的问题。如果您曾阅读过加密论文或文章，作者通常会尝试将这些奇怪的概念转化为更直观和熟悉的东西，并推出Alice和Bob。

爱丽丝和鲍勃是世界上最不起眼的双重行为，他们只有一个例程。当爱丽丝和鲍勃出现时，他们将立即开始用看似随意的规则开始一系列猜谜游戏。有时爱丽丝或鲍勃不知道一些规则，这些规则没有准确地清除。这个游戏通常发生在洞穴里，爱丽丝可能会有一些硬币（公共硬币）。当Bob开始对如何将均匀分布的随机数生成器与散列函数区分开来时，你就知道自己*真的*在享受这种对待。

我不喜欢爱丽丝和鲍勃。我发现他们的存在是无益的。尽管如此，由于我没有设法直观地解释零知识证据，我在本文中引用了它们，但我想澄清一点; 我对此并不满意。

# **解剖机密交易**

在描述协议的*作用*之前，我想从我们*需要的*东西开始，这样当我介绍一个概念时，我可以解释为什么它有价值。我们想要一种用加密数字表示“余额”的方法。例如，我没有分类帐记录，我有20个以太坊，而你有5个，这些数字是加密的。

我们不能将其记录为简单的加密分类帐，因为如果我想向您汇款，我需要能够弄清楚您的新加密余额应该是什么 - 但我不知道您的原始余额，所以这是难做。

因此，我们不是将所有者映射到余额，而是通过加密“注释”的概念将余额映射到所有者。

- 一张纸币值得一些定义的金额，并拥有一个所有者。
- 如果我拥有多个音符，我可以将它们组合成一个音符。
- 如果我有一张纸条，我可以将它分成多个纸币。这些笔记可以有不同的所有者

我可以通过拆分票据并让收件人拥有一个（或多个）票据来转移“价值”。输入票据的总和等于输出票据的总和

[![IMG](https://camo.githubusercontent.com/f066f33dfa36ec3c74c79d45b444a1834cb4ffb4/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f312a2d7a4d4b7778754750556a4137536e796653477344772e706e67)](https://camo.githubusercontent.com/f066f33dfa36ec3c74c79d45b444a1834cb4ffb4/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f312a2d7a4d4b7778754750556a4137536e796653477344772e706e67)

完美平衡的“加入 - 拆分”交易。

在加密笔记的世界中，我们需要什么才能进行机密交易？

- 一种将值加密到笔记中的方法
- 一种证明某些输入音符值的总和的方法，等于某些输出音符的值的总和

为了获得这些东西，我们需要深入研究椭圆曲线密码学的世界。

# ****椭圆曲线加密和同态加密\****

椭圆曲线具有相对简单的公式，例如我们使用的曲线具有公式**y²=x³+ 3**（3是重要的......）。如果在一张纸上绘制，我们可以假装它看起来像这样：[![IMG](https://camo.githubusercontent.com/9e7e6beb37138197905e18b8c69a430e43f34d7d/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f312a3866765861706175697342454f4870706163666a6b772e706e67)](https://camo.githubusercontent.com/9e7e6beb37138197905e18b8c69a430e43f34d7d/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f312a3866765861706175697342454f4870706163666a6b772e706e67)椭圆曲线。不是正确的椭圆曲线，但这个看起来不错

我们使用椭圆曲线，因为它们可用于创建单向函数（可以从A→B映射，但如果给定B，则无法计算出A），这些函数可以保留一些数学运算。

这是它的工作原理。如果曲线上有两个点，则在它们之间绘制一条直线，找到该线在第三次撞击曲线的位置（这将始终发生），然后在y轴上反转该点。结果点是我们“添加”操作的结果。[![IMG](https://camo.githubusercontent.com/a5799e41c2d42ed997fdf8d237ac5cc7f8ba6f83/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f312a554f5a6c704f35304e5655623839572d302d6c4957412e706e67)](https://camo.githubusercontent.com/a5799e41c2d42ed997fdf8d237ac5cc7f8ba6f83/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f312a554f5a6c704f35304e5655623839572d302d6c4957412e706e67)椭圆cuve点加法

向自身添加点时，绘制的线是该点处曲线的切线。

我们需要在y轴上进行反演，因为没有它，我们的“加法”不是关联的：**（P + Q）+ R**不等于**P +（Q + R）。**

**但为什么？**

好问题！我们可以使用点加法来定义**椭圆曲线标量乘法**。如果我们有一个点，**P**，和一个整数**X**，我们可以“乘” **P**由**X**，但加入**P**自身**X**倍。

如果仔细选择椭圆曲线参数，则标量乘法是**单向函数**。如果我有**x**和**P，**我可以很容易地计算**x•P**。但如果我有**P**和**x•P**，我就无法弄明白**x。**当然，条款和条件适用。这仅在**x**是随机数时才有效，或者在其中添加了随机性（如果**x**是可预测的，那么通过试错法蛮力技术可以更容易地计算出来）。

**但为什么？**

好问题！有更便宜和更快的单向函数，如散列算法。但椭圆曲线保留了它们加密的值的一些数学属性。

取两个随机整数**x**和**y**并计算x **•G **和y **•G **。现在将它们加在一起。将所得点是通过添加在一起x和y，得到相同的点*，然后*乘以结果**摹**。

**P = x•G + y•G =（x + y）•G**

这种执行**同态加法的**能力意味着我们可以对加密数字执行添加，就*好像它们没有加密一样*，这非常有用。

当然，条款和条件适用。在椭圆曲线上具有同态加法的问题（其中之一）是以*非常*大的素数**p**为模进行加法。对于我们使用的曲线，这等于`21888242871839275222246405745257275088548364400416034343698204186575808495617`。

想象一下，我们想要验证“交易”。我有一个值为**0**的音符，我想把它转换成值为**-1**和**1**的音符**。**让我们将这些值表示为椭圆曲线上的'音符'：**-1•G**和**1•G**。

当然，**0•G = -1•G + 1•G。**因此，我们可以满足join-split事务所需的平衡关系。但对于我们的椭圆曲线，**-1**实际上是**p-1**，这是一个**巨大的**数字！

如果我们使用这种逻辑来验证以美元计价的机密交易，我们刚刚创建了一个价值超过可观察世界中存在的金额的“票据”，这有点问题。

# ****救援范围证明\****

我们需要一个**范围证明**来处理这个问题。如果我们检查进入我们的密码系统的每个加密数字是否比**p / 2** **小**许多个数量级**，**那么它永远不可能在模数边界周围“包裹”并创建“负数”。

但我们现在有另一个问题。如果同态算术的模块化性质是我们故事中的恶棍，那么范围证明就不像是一个带有心脏和情节盔甲的勇敢英雄，更像是一个凶悍的雇佣兵，他们将所有东西都摧毁到裤子的弹性。范围证明很**昂贵。**验证大多数范围证明的计算成本为使用它们的加密协议增加了显着的开销。

例如，一种常见的方法是创建一个数字中每个位的加密表示，然后证明每个位都是0或1.但是对于32位数字，你需要验证32个零知识证明。有一些巧妙的技术可以将这些校样的大小缩小并将它们组合成一个大型校样，但验证程序所需的计算量仍然会随着加密数字可能包含的位数而扩展。

对于以太坊协议，这转化为快速达到块气限制的天然气成本。

## **通过数字签名进行范围校样**

想象一下场景。您是零知识人民代表民主党的骄傲和忠诚的公民。在此时间表中，由于登记处的文书事件，您被称为Alice; 党不犯错误。

今天，你正忙着在面包线上排队，以便为你的家人喂饱一周。

但是，你有一个问题。委员鲍勃只会向那些国家不服从分数足够低的正直公民出售面包。

当然，你是个骄傲的和忠诚的公民，*做*其实posess足够低的分数。然而，如果你只是*告诉*鲍勃你的分数，你将被判为5年的酸硼洞穴中的苦役，因为它不是GDPR-2.0的编纂者。

你的一个优点是鲍勃，作为遵守规则的坚持者，绝对*喜欢*用公共硬币抽象猜谜游戏。所以你可以使用零知识证明。

然而，鲍勃只有一个8位*Robotron-1999人民的制表机，*并且只有一分钟的时间来处理您的证明，然后才会被踢出面包线进行游荡。

爱丽丝如何向鲍勃展示她的分数低于阈值的*有效范围证据*？爱丽丝的家人会再喂一周吗？

正是在这个悬崖吊架上，我们将深入探讨AZTEC协议及其范围证明的深度。

## ****使用懒惰范围样张保存一天\****

在软件工程中，我们有一个称为**惰性评估**的原则**。**简单地说，除非必须，否则不要做任何事情，只有在需要时才这样做。验证范围证明可能是昂贵的，但验证**其他人**已验证范围证明**要**便宜得多。

## ****数字签名和范围证明\****

制作范围证明其他人的问题在协议中引入了**受信任的设置**，由相关的“其他人”执行。在此设置阶段，我们生成一个随机整数**y**，即可信设置**私钥**（这是我们协议的'有毒废物'）**。**可信设置**公共密钥**发布（**y提示•G）** ，连同*数字签名*为**每一个**我们在我们的范围内证明（如0到1亿美元）容忍整数。一旦完成，必须销毁**y的**知识。

现在，为了执行范围证明，我们需要做的就是提供签名，并证明它是由**y**签名的。如果我们正确地完成了我们的工作，这意味着签名中的整数也在允许的范围内，因为那些是唯一创建的签名。

这确实带来了**y**没有被破坏的风险，并且有关它的信息被泄露。但是，我们有一个多方计算协议，可以让我们的可信设置由大量人员（理想情况下为数千人）执行。每个人都会产生自己的“有毒废物”，执行他们的计算，然后摧毁他们的废物。只有**一个**人必须诚实行事并销毁其有毒废物，以确保整个协议的安全。

在这里，保持这些：[![IMG](https://camo.githubusercontent.com/938db4e80432a2467aaddff42a1394094a31a116/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f302a7374427a524c414d59696239486776522e706e67)](https://camo.githubusercontent.com/938db4e80432a2467aaddff42a1394094a31a116/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f302a7374427a524c414d59696239486776522e706e67)

点**μ**是**Bohen-Boyen**（BB）签名的一种形式，并且是**可信设置签名数据库的一部分**。整数**k**代表我们在范围证明中接受的数字，因此我们的范围内的每个整数都有一个签名。整数**y**表示特殊的**可信设置**私钥，点**T**表示可信设置公钥。

如果给出点**μ**和标量**k**，我们可以在不知道**y**是什么的情况下检查**μ**是否确实是签名; 我们只需要**牛逼**。

为什么是这样？好吧，我们的策略是将比率**G** **：y•G**嵌入到范围寄存器中每个数字的加密中，因此以某种方式*可测试*但也*无法恢复。* **双线性预测**测试指数的比率，使我们能够神奇地盲目地测试我们的'签名'凸轮来自由**y**签署的预先构建的列表（我们可以通过知道**y**来伪造这个证明，这就是为什么它是最重要的**y的**知识被摧毁了）。

我们知道**G**和**y•G**的值。如果我们还可以得到**μ**和**y提示•μ**，我们可以验证（之间的映射**g ^ - > y提示•G）**和**（μ - >** **y提示•μ）**是相同的，因此，我们可以**证明**该**μ**是从一个签名签名数据库。这是我们对**双线性配对**比较的要求。

为此，我们需要**y•μ。**为此，我们需要计算这个数量：[![IMG](https://camo.githubusercontent.com/2a895a10ae36ea9d63c7698b0920b53c7180c840/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f302a37776770374c324f793132426d6e47302e706e67)](https://camo.githubusercontent.com/2a895a10ae36ea9d63c7698b0920b53c7180c840/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f302a37776770374c324f793132426d6e47302e706e67)

如果我们将**G**重写为（**（y -k）/（yk））•G**，并且以**G表示****μ**，这可能更有意义：[![IMG](https://camo.githubusercontent.com/92479cbbd1ba584b3ae40f3d12b5c8cfd41bbd11/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f302a705333716a32664b57344673793764532e706e67)](https://camo.githubusercontent.com/92479cbbd1ba584b3ae40f3d12b5c8cfd41bbd11/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f302a705333716a32664b57344673793764532e706e67)

由于同态加法，**G**的'标量乘数' 是**y /（yk）**，导致我们：[![IMG](https://camo.githubusercontent.com/f472ba48459cb14d73f1609d73a01882806a4ce5/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f302a746f6c50664937567952424f425563482e706e67)](https://camo.githubusercontent.com/f472ba48459cb14d73f1609d73a01882806a4ce5/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f302a746f6c50664937567952424f425563482e706e67)

# ****验证Boneh-Boyen签名：双线性对\****

对于任何有效的Boneh-Boyen特征**μ**，我们可以计算**y•μ，**尽管不知道**y**的值。但是，我们如何知道此签名是由受信任的安装私钥签署的，而不是伪造的？

如果我们有这两点，我们可以通过**双线性配对**检查**y**确实是正确的私钥。

Vitalik [写了一篇关于双线性配对的精彩文章，](https://medium.com/@VitalikButerin/exploring-elliptic-curve-pairings-c73c1864e627)它解释了它比我更好，如果你想了解更多，我建议阅读它。总而言之，配对执行椭圆曲线点的一种乘法。如果我在两个点上执行配对操作：**e（a•P，b•R）**，哪个点包含标量**a**和**b**无关紧要，因为结果将它们相乘。例如，以下四个配对操作会创建相同的结果：

**e（a•P，b•R）= e（b•P，a•R）= e（ab•P，R）= e（P，ab•R）**

因此，取我们的**可信设置**公钥**，T = y•G。**如果给出椭圆曲线点**μ**和**y•μ**，我们可以通过将这些点分别与**T**和**G**配对来检查是否是这种情况。检查以下等式的两边是否匹配：[![IMG](https://camo.githubusercontent.com/5486e210493728befe28fd5cbe2bd30234849e6d/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f302a4c412d644b555846326d316a395371752e706e67)](https://camo.githubusercontent.com/5486e210493728befe28fd5cbe2bd30234849e6d/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f302a4c412d644b555846326d316a395371752e706e67)

综上所述，我们可以验证椭圆曲线点**μ**是否是整数**k上**的Boneh-Boyen签名，由可信设置私钥**y**签名，通过验证以下等式：[![IMG](https://camo.githubusercontent.com/829c713240bed0282d86001af93588264767d2f2/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f302a6d68437056356d6a425765684e514e4b2e706e67)](https://camo.githubusercontent.com/829c713240bed0282d86001af93588264767d2f2/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f302a6d68437056356d6a425765684e514e4b2e706e67)

从中可以看出，如果一个人可以证明他们有一个由**y**签名的签名**，**并将签名的值**k** **链接**到加密值，那么我们就知道加密值只能是签名的整数之一值得信赖的设置。即我们有范围证明。Tadaaa ...

重要的是，这可以在没有任何人真正知道**y** *是*什么的情况下完成，因为**y**在可信设置过程结束时被销毁。

所有这一切的价值在于验证方程并不关心**k的**大小。范围越大，可信设置创建的*签名数据库*越大，但验证此范围证明的计算成本始终是恒定的。

## ****但等等，还有更多！使用嵌入范围证明创建加密方案\****

在我们的可信设置协议中，我们为我们在范围证明中接受的每个整数创建了一个椭圆曲线点**μ**，并将它们放入数据库中。我们还发布了公钥**T.**

所以现在，我们可以选出其中一个点并证明它是由**T**签署的。但这并**没有**给我们所需的机密性。

如果我看到其他人在事务中使用签名点，我可以只查找数据库中该点对应的整数！

我们需要添加一个**随机**因子。选择一个随机变量**a**。这是我们的**查看键**。现在，如果我们想要在整数**k**上构建范围证明，我们选择所需的点**μ**并将其乘以查看键。我们称之为**γ**[![IMG](https://camo.githubusercontent.com/bd68c48b1157f079f08a97eecaf86b4aacd2be39/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f302a45765f776f72754e6d7557386e6b36792e706e67)](https://camo.githubusercontent.com/bd68c48b1157f079f08a97eecaf86b4aacd2be39/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f302a45765f776f72754e6d7557386e6b36792e706e67)

为了证明**γ**是由**y**签名的签名，我们需要能够得到**y·γ**。而不是**y•μ**。但这很简单，只计算**k•γ+ a•G**而不是**k•μ+ G：**[![IMG](https://camo.githubusercontent.com/77bd5039b789136604da0f8e7795713bb1f988df/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f302a6c583454775064796d707732513831502e706e67)](https://camo.githubusercontent.com/77bd5039b789136604da0f8e7795713bb1f988df/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f302a6c583454775064796d707732513831502e706e67)

让我们引入一个点**σ**来表示：**σ** = **y•γ。**现在，为了证明我们在给定点对**（γ，σ）的情况下**有一个有效的签名，验证者必须验证以下方程是正确的：[![IMG](https://camo.githubusercontent.com/6527653480fb9b681fefef0fc64f545a5678c865/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f302a54526279555678367237756d4f4e54392e706e67)](https://camo.githubusercontent.com/6527653480fb9b681fefef0fc64f545a5678c865/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f302a54526279555678367237756d4f4e54392e706e67)[![IMG](https://camo.githubusercontent.com/7cf7f208a8f277d22ee6250867743a0aee081000/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f302a73497a2d34584d6675706561747078492e706e67)](https://camo.githubusercontent.com/7cf7f208a8f277d22ee6250867743a0aee081000/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f302a73497a2d34584d6675706561747078492e706e67)

这里的*值*是观察者不能将**γ**链接到签名数据库中的签名，因为我们用查看键**a**对签名进行了加扰。*但是，*我们可以*仍然*证明，无论**γ**包含，它仍然是由受信任的设置私钥签名的Boneh-Boyen的签名**Ÿ**，即使没有人真正知道这是什么，以及我们所有一起工作的**牛逼**。

# ****全部放在一起：AZTEC'承诺'功能\****

你可能已经注意到这个双线性配对验证方程需要整数**k**和**a**。验证公式是一个“聪明的合同”验证算法内运行，我们当然**不**希望这些广播整数！这就是重点。

这是相对简单的，可以通过**零知识证明**来完成。但这本身就是另外一篇文章，现在让我们假设可以做到这一点。

两点（**γ，σ**）表示整数**k**的**加密**。给定这两点，只有**一个**特定的**k**值和**一个**特定的**a**值将满足验证方程。

这是因为**γ**是可信设置私钥**y**的函数，而生成点**G**不是。假设可靠设置正确完成，并且**y的**知识已经被破坏，则不可能通过在整数（**a**）乘以**G中**添加项来“分解”整数（**k**）乘以**γ**，而不会破坏椭圆曲线加密。

这是可用加密方案所需的**计算绑定**属性。

通过检查点**（γ，σ）**来收集关于**k**的任何信息是不可能的，除了它在我们的范围证明边界内的事实。这是因为查看键（**a）**充当随机因素，需要在提取**k**之前将其考虑在内。这是**完全隐藏的**属性，是任何加密方案所需的第二个属性。

当然，如果我给你一个加密点对**（γ，σ）**和查看键（**a**），你可以弄清楚**k**是什么（我的意思是，它有一个原因叫做查看键！）。这是因为我们可以通过计算**σ - a•G**来计算**k•γ**。现在我们有**k•γ**和**γ，**我们可以通过强力算法提取**k**（因为**k**来自的整数集相对较小，比如介于一百万到十亿之间）。

正是这种承诺功能，一种包含隐式范围证明的加密方案，可以有效地验证AZTEC协议的零知识证明。

# AZTEC协议1.0.0

AZTEC协议的技术规范

# **目录**

- 建筑

  - AZTEC密码引擎
  - AZTEC注释和ABI编码

- Note Registry

- ACE，AZTEC密码引擎

  - 验证AZTEC校样 - 定义校样的标识符
  - 制定机密转移指令 - 定义proofOutputs的ABI编码
  - ABI编码 `bytes proofOutputs`
  - ABI编码 `bytes proofOutput = proofOutputs[i]`
  - 在ACE中编目有效的证明
  - ACE所有者

- 的主要责任 

  ```
  ACE
  ```

  - 分离证明验证和注释注册表交互

- 合同互动

  - 零知识dApp合同交互，双边交换的示例流程
  - 多边机密交易背后的理由

- 验证AZTEC证明

- 注意注册实现

  - 创建便笺注册表
  - 注意注册表变量
  - 智能合约实施
  - 可升级功能

- 处理转移指令

  - 关于ERC20令牌转移的说明

- Minting AZTEC笔记

  - 铸币和代币

- 燃烧AZTEC笔记

- 与ACE交互：zkAsset

  - 创建机密资产
  - 发布保密交易：confidentialTransfer
  - 发布委托机密交易：confidentialTransferFrom
  - 应用权限

- 证明验证合同

  - JoinSplit.sol
  - Swap.sol
  - Dividend.sol
  - PublicRange.sol
  - PrivateRange.sol
  - JoinSplitFluid.sol

- 实用程序库的规范

- 附录

  - 答：防止碰撞和前线运行
  - B - 通过AZTEC注释的兴趣流

- 词汇表

# **建筑**

AZTEC协议通过构建AZTEC兼容的零知识证明，实现高效的机密交易。具体而言，该协议侧重于优化机密*结算*和其他形式的价值转移

该协议的架构旨在针对以下因素进行优化：

1. 可定制性 - AZTEC资产必须具有机密交易语义，可以对其进行修改以适应用户的目的
2. 互操作性 - 不同的AZTEC资产必须符合dApp可用于解决机密交易的标准接口
3. 效率 - 在验证机密交易时不应执行冗余计算
4. 合格的可升级性 - 随着对底层加密协议的改进，以及在AZTEC中添加额外的证明系统，现有的机密资产应该能够享受这些改进带来的好处。与此同时，AZTEC的用户必须能够确信他们可以选择退出这些升级 - 用于验证现有零知识证明的验证算法是不可变的。此外，随着对注释注册表逻辑的升级，用户必须可以选择从这些升级中受益，同时还可以选择退出。

## **AZTEC密码引擎**

我们协议的重点是这个加密引擎（ACE.sol）。ACE是AZTEC零知识证明正确性的最终仲裁者。AZTEC资产订阅ACE并呼吁它验证证明。

ACE将零知识证明数据转换为*指令* - 以下说明：

1. AZTEC注意到要创建
2. AZTEC指出要被销毁
3. 需要转移的公共令牌

在内部，ACE将创建每个证明指令的唯一表示并存储它

## **ABI编码和AZTEC数据'类型'**

零知识密码术的本质意味着以零知识证明*输入*和零知识证明*输出*的形式在链上处理大量数据。

因为在外部函数中使用结构仍然是一个实验性特征，所以AZTEC协议为结构类数据类型定义了自己的ABI编码。这些对象由`bytes`类型表示，其中bytes数组的内容包含根据AZTEC协议的ABI规范格式化的数据。

### **AZTEC注意ABI**

ACE的一个关键特性是支持多个音符“类型”的能力。不同的笔记类型使引擎能够支持使用不同技术表示加密值的零知识证明。

例如，当前实现的基本AZTEC注释是表示加密值的最有效方式，但是它类似UTXO的形式可能不适合某些应用程序。另一方面，一旦实施，ElGamal'财政'票据可用于模拟更传统的账户余额模型，其中余额是加密的。

所有注释使用相同的基本结构，但具有不同的`publicKey`值。每个AZTEC零知识证明都明确定义了它所使用的音符类型。在任何情况下都不可能在零知识证明中使用错误“类型”的注释。

注释的ABI编码如下：

| 抵消         | 长度   | 名称     | 类型    | 描述                                 |
| ------------ | ------ | -------- | ------- | ------------------------------------ |
| 为0x00       | 为0x20 | ID       | uint256 | 注释的“类型”标识符                   |
| 为0x20       | 为0x20 | 所有者   | 地址    | 记录所有者的以太坊地址               |
| 0x40的       | 0X60   | noteHash | bytes32 | 音符的椭圆曲线点的哈希：伽马和西格玛 |
| 0X60         | L_pub  | 公钥     | 字节    | 注释的公钥，用于加密值               |
| 0x60 + L_pub | L_met  | 元数据   | 字节    | 特定于音符的元数据                   |

### **类型1：UTXO备注**

这是默认的笔记类型，目前由协议使用。本笔记的ABI格式`publicKey`如下：

| 抵消   | 长度   | 名称       | 类型    | 描述                       |
| ------ | ------ | ---------- | ------- | -------------------------- |
| 为0x00 | 为0x20 | 伽马       | bytes32 | （压缩的）bn128组元素      |
| 为0x20 | 为0x20 | 西格玛     | bytes32 | （压缩的）bn128组元素      |
| 0x40的 | 为0x21 | 短暂的关键 | bytes33 | 用于恢复查看密钥的短暂公钥 |

### **类型2：El-Gamal国库券**

国库券将使单个“账户”的余额由单一的国库券（而不是多种AZTEC UTXO型票据）代表。它们使用的气体比AZTEC注意要贵一些，仅用于一小部分AZTEC零技术样张。

| 抵消   | 长度   | 名称             | 类型    | 描述                                        |
| ------ | ------ | ---------------- | ------- | ------------------------------------------- |
| 为0x00 | 为0x20 | ownerPubKey      | bytes32 | （压缩）bn128组元素，映射到注释所有者的公钥 |
| 为0x20 | 为0x20 | noteEphemeralKey | bytes32 | （压缩）bn128组元素，音符短暂键的公钥组件   |
| 0x40的 | 为0x20 | noteCommitment   | bytes32 | （压缩）bn128组元素，核心El-Gamal承诺       |
| 0X60   | -      | 元数据           | 字节    | 与note关联的自定义元数据                    |

### **元数据**

`metaData`是笔记的通用数据字段。AZTEC零知识证明验证器的逻辑不使用它，而是包含实现和应用程序特定信息，并通过涉及注释的事件进行广播。

该`metaData`架构具有默认组件，然后，可以在需要的相关联的功能可以设置附加的CustomData组件。默认情况下，它使用临时密钥填充，可用于恢复笔记查看键（参见下文）。可以通过调用附加其他自定义数据`note.setMetaData()`，从而生成如下架构：

| 抵消                                     | 长度                | 名称                    | 类型    | 描述                                    |
| ---------------------------------------- | ------------------- | ----------------------- | ------- | --------------------------------------- |
| 为0x00                                   | 的0x41              | ephemeralKey            | bytes32 | ephemeralKey用于密钥交换                |
| 的0x41                                   | 0x61                | approvedAddressesOffset | uint256 | 相对偏移量`address[] approvedAddresses` |
| 0x61                                     | 0×81                | encryptedViewKeysOffset | uint256 | 相对偏移量`bytes[] encryptedViewKeys`   |
| 0×81                                     | 0xa1                | appDataOffset           | int256  | 相对偏移量`bytes[] appData`             |
| 0xa1                                     | L_addresses         | approvedAddresses       | 地址[]  | 批准访问查看密钥的地址                  |
| 0xa1 + L_addresses                       | L_encryptedViewKeys | encryptedViewKeys       | 字节[]  | IES为每个地址加密查看密钥               |
| 0xa1 + L_addresses + L_encryptedViewKeys | L_appData           | 应用程序数据            | 字节[]  | 应用程序特定数据                        |

因此，包括在`metaData`：注释临时密钥，要批准的地址，一系列IES加密查看密钥，用于授予对第三方的注释访问权限和应用程序特定用例的数据。这些用于启用如下定义的各种功能。

**使用1：使用临时密钥恢复查看密钥**

每个音符查看键应该是不同的，但是用户不必管理大量独特的查看键。另外，如果用户A希望向用户B发送笔记，则他们应该能够导出A可以恢复的查看关键字。这个过程应该是非交互式的。

解决方案是在“短暂的”公钥/私钥对与笔记所有者的公钥之间使用共享秘密协议。如果收件人有隐形钱包，则可以使用此协议的扩展来派生“隐形”地址。目前，我们的V1 API使用基本的共享密钥协议，易于使用（传统的以太坊钱包可以拥有这些AZTEC笔记）。在智能合约级别，协议与隐藏地址向前兼容。

因此，metaData字段的第一次使用是存储用户恢复其笔记查看键所需的数据 - “短暂”公钥。

**使用2：授予视图密钥访问权限**

注意，通过将IES加密的查看密钥和相关的已批准地址编码到第三方，可以直接向第三方授予查看密钥访问权限`metaData`。这允许一种方法，由此可以有效地计算查看密钥访问，而不必使用短暂密钥。

该`zkAsset.updateNoteMetaData(bytes32 noteHash, bytes calldata metaData)`功能支持授予查看键。这允许`metaData`更新已存在的注释，并因此授予对其他方的查看密钥访问权限。

**使用3：应用程序特定数据**

最后，应用程序特定数据可以附加到`metaData`注释中。这为数字资产构建者提供了将自定义数据附加到AZTEC注释以用于特定于应用程序的实用程序的选项。

# **Note Registry**

AZTEC注释合同是AZTEC加密引擎的一个子集，但我们明确地描述了它对协议的重要性。

note注册表包含存储变量，用于定义给定地址的有效AZTEC注释集。预计此地址将映射到智能合约，但不会强制执行。

注释注册表制定有效AZTEC校样生成的指令 - 创建和销毁所需的注释，以及传输任何所需的令牌。

注释注册表`owner`是唯一可以发出更新注册表的指令的实体。`NoteRegistry`只会制定由有效的AZTEC证明生成的指令，因为除非满足**平衡关系，**否则不会创建/销毁注释至关重要。

因为使用ACE注释注册表的每个机密资产都可以对所有*其他* ACE注释注册表的状态完整性有100％的信心，所以它可以将来自一个注册表的AZTEC注释表示为第二个注册表中注释的百分比，反过来，对于支付股息的机密资产和利用收入流的机密资产非常有用。

# **ACE，AZTEC密码引擎**

该`ACE.sol`合同是负责验证集AZTEC零知识证明和执行涉及AZTEC笔记任何传送指令。ACE是所有AZTEC票据登记处的控制人，并且作为AZTEC票据和已转换为AZTEC票据的任何令牌的保管人。

虽然可以定义ACE外部的注释注册表，但无法保证这些合同注释注册表的状态，并且只有一部分证据可用（即，如果资产使用ACE注释注册表，则转移来自AZTEC的说明证明涉及多个注释注册表只有在每个注释注册表由ACE控制时才会生效。

ACE具有以下界面：

```
/** * @title IACE * @author AZTEC * @dev Standard defining the interface for ACE.sol * Copyright Spilsbury Holdings Ltd 2019. All rights reserved. **/interface IACE {    function mint(        uint24 _proof,        bytes calldata _proofData,        address _proofSender    ) external returns (bytes memory);    function burn(        uint24 _proof,        bytes calldata _proofData,        address _proofSender    ) external returns (bytes memory);    function validateProof(uint24 _proof, address _sender, bytes calldata) external returns (bytes memory);    function clearProofByHashes(uint24 _proof, bytes32[] calldata _proofHashes) external;    function setCommonReferenceString(bytes32[6] calldata _commonReferenceString) external;    function invalidateProof(uint24 _proof) external;    function validateProofByHash(        uint24 _proof,        bytes32 _proofHash,        address _sender    ) external view returns (bool);    function setProof(        uint24 _proof,        address _validatorAddress    ) external;    function incrementLatestEpoch() external;    function getCommonReferenceString() external view returns (bytes32[6] memory);    function getValidatorAddress(uint24 _proof) external view returns (address validatorAddress);    function getNote(address _registryOwner, bytes32 _noteHash) external view returns (        uint8 status,        uint40 createdOn,        uint40 destroyedOn,        address noteOwner    );}
```

## **验证AZTEC校样 - 定义校样的标识符**

ACE支持多种类型的零知识证明，这一系列的证明将随着时间的推移而增长。重要的是要以系统的方式对这些证据进行分类。

ACE证明标识和版本控制系统具有以下特征：

- 可扩展性。AZTEC的模块化证明系统支持可组合的机密交易语义 - 添加更多证据使这些语义更具表现力。此外，它允许AZTEC协议支持基本上新型的零知识证明技术，如以太坊秤（例如防弹，zk-snarks）
- 选择退出功能。如果资产控制人只想听取一部分证据（例如，是否按照他们的条款收听新添加的证据。这对于具有零知识证明的内部审查流程的资产很重要）
- 合格的不变性。给定证明ID的验证器代码永远不会改变。AZTEC必须能够在以后发现包含错误的情况下取消激活证明，但是通过实例化新的验证者合同以及新的证明ID来表示对证据的任何升级或改进。

证明由标识符唯一定义`uint24 _proof`。ACE存储一个映射，该映射将每个映射映射`_proof`到验证所讨论的零知识证明的智能合约的地址。

它没有采用“通用”验证智能合约，而是选择将这些合同分开以获得最大的灵活性。验证者合同不应该是可升级的，保证AZTEC证明的用户可以确信他们使用的证据不会发生变化。通过添加新的验证器合同和新校样来实现升级和更改。

该`uint24 _proof`变量包含三个`uint8`变量的串联（此压缩的基本原理是减小`calldata`大小和简化接口。我们的javascript API自动组成正确的证据`_proof`，最大限度地减少AZTEC上的构建器必须跟踪的变量数量。

格式如下（从最重要的字节到最低有效字节）

| 名称 | 类型  | 描述                               |
| ---- | ----- | ---------------------------------- |
| 时代 | UINT8 | 这个证明所属的广泛家庭             |
| 类别 | UINT8 | 这个证明的一般功能                 |
| ID   | UINT8 | 证明的标识符，用于指定的类别和纪元 |

没有使用语义风格的版本系统，因为证明`epoch`定义了功能以及版本控制的形式。具有相同`uint8 id`但具有不同的`uint8 epoch`证据不必执行相同的功能，并且来自后者的证明`epoch`并不比来自较早的证明严格“更好” `epoch`。

例如，如果AZTEC样张的基本系列适用于不使用可信设置的机密交易，则这些样张将按新分类`epoch`。然而，这些并不是对早期时代的严格升级，因为验证这些证据的气体成本几乎要高出一个数量级。

同样，当实施机密投票机制时`ACE`，这些机制将由一个单独定义，`epoch`以强调其与机密交易的不同功能。

该`uint8 category`变量表示具有以下四个值的枚举：

| 值   | 名称 | 描述                             |
| ---- | ---- | -------------------------------- |
| 0×01 | 均衡 | 满足平衡关系的证明               |
| 0×02 | 薄荷 | 可以用来制作AZTEC笔记的样张      |
| ×03  | 烧伤 | 可以用来刻录AZTEC笔记的样张      |
| 0×04 | 效用 | 实用证明不能单独用于发出票据转移 |

的`ACE`合同有独立的逻辑来处理`BALANCED`，`MINT`和`BURN`校样，如后两者明确违反用于防止双重消费的平衡关系。这些`MINT`和`BURN`样张是为完全私有的AZTEC资产而设计的，没有ERC20令牌的资产，其中AZTEC笔记是价值的主要表现。由此，对其使用有额外的限制。

有关铸造和燃烧的更多信息，请参阅薄荷和燃烧部分。

该`UTILITY`证据被设计用于需要额外的验证逻辑可以执行事务之前的资产。例如，资产可能要求交易者在交易处理之前证明他们拥有的资产总额不到资产总额的10％。我们的`dividend`实用程序证明支持这一点。

此规范包含每个当前支持的证明ID的说明。可以在[AZTEC协议文件中](http://www.github.com/AZTECProtocol/AZTEC)找到验证者使用的零知识证明的正式描述。

组合在一起时，`uint8 epoch, uint8 category, uint8 id`为每个类别创建65025唯一证明标识。鉴于零知识加密协议的复杂性以及在集成之前必须进行的验证，`ACE`不可能在内部需要更多`65025`类型的零知识证明`ACE`。

## **制定机密转移指令 - 定义proofOutputs的ABI编码**

AZTEC使用的零知识证明之间存在很大差异。因此，以及创建简单界面来验证校样的愿望，证明*输入*的界面是通用的。AZTEC证明接受三个参数：`bytes data, address sender, uint256[6] commonReferenceString`。该`commonReferenceString`由ACE提供。该`data`变量包含有问题的零知识证明数据，该`address sender`字段用于消除前沿运行。ABI编码`bytes data`特定于给定的验证器智能合约。

零知识证明的**输出**是要执行的指令列表。重要的是，这些`proofOutput`变量符合通用标准，以便现有的机密资产可以从未来的证据中获益。

指令必须包含以下内容：

- 要销毁的票据清单，“输入票据”
- 要创建的注释列表，“输出注释”
- 如果转让公共代币，涉及多少代币，谁是受益人以及转让的方向是什么？（进入ACE或ACE？）

除此之外，ACE必须支持一个产生*多个*指令的零知识证明（例如，`Swap`证明为两个不同的资产提供转移指令）。

该`UTILITY`类别中的证明也符合此规范，但在此上下文中，不会创建或销毁“输入”和“输出”注释。

总而言之，任何AZTEC验证器智能合约的输出都是一个`bytes proofOutputs`变量，它对动态的`bytes proofOutput`对象数组进行编码。ABI编码如下：

## **ABI编码 bytes proofOutputs**

| 抵消                                                  | 长度           | 名称            | 类型           | 描述                                                         |
| ----------------------------------------------------- | -------------- | --------------- | -------------- | ------------------------------------------------------------ |
| 为0x00                                                | 为0x20         | 长度            | uint256        | `proofOutput`对象的数量                                      |
| 为0x20                                                | （0x20 *长度） | 偏移            | uint256 [长度] | 0x20大小的变量数组，包含每个相应`proofOutput`对象的相对偏移量 |
| 0x20 +（0x20 *长度）+（\ sum_ {j = 0} ^ {i-1} L [j]） | L [I]          | proofOutput [I] | 字节           | 该`bytes proofOutput`对象                                    |

## **ABI编码 bytes proofOutput = proofOutputs[i]**

| 抵消       | 长度   | 名称          | 类型    | 描述                                     |
| ---------- | ------ | ------------- | ------- | ---------------------------------------- |
| 为0x00     | 为0x20 | inputsOffset  | uint256 | 相对偏移量 `bytes inputNotes`            |
| 为0x20     | 为0x20 | outputsOffset | uint256 | 相对偏移量 `bytes outputNotes`           |
| 0x40的     | 为0x20 | publicOwner   | 地址    | 正在转移的令牌所有者的以太坊地址         |
| 0X60       | 为0x20 | publicValue   | int256  | 转移的公共“价值”的数量                   |
| 0x80的     | 为0x20 | 挑战          | uint256 | 产生此输出的零知识证明中使用的“挑战”变量 |
| 0XA0       | L_1    | inputNotes    | 字节    | 该`bytes inputNotes`变量                 |
| 0xa0 + L_1 | L_2    | 输出注        | 字节    | 该`bytes outputNotes`变量                |

两个`bytes inputNotes`和`bytes outputNotes`是AZTEC笔记动态数组，根据AZTEC音符ABI规范编码。

该`int256 publicValue`变量是一个*签名的*整数，因为负的值视为令牌被传递*来自* `address publicOwner`和进入`ACE`。同样，正值被解释为转移*到的* 令牌`address publicOwner`。

应该注意，`int256 publicValue`它不代表令牌的绝对数量。内部的每个注册表`NoteRegistry`都有一个关联`uint256 scalingFactor`，它定义了1个单位的AZTEC注释“值”表示多少个ERC20令牌。这种映射是必要的，因为AZTEC音符值大约是30位整数（CAVEAT HERE），并且需要使用缩放因子将256位ERC20令牌音量映射到30位AZTEC值。

该`uint256 challenge`变量用于确保每个变量`bytes proofOutput`生成唯一的哈希。挑战变量是每个AZTEC零知识证明所必需的，并且本身是证明的唯一伪随机标识符（两个令人满意的零知识证明不能产生没有哈希冲突的匹配挑战变量）。对于在`bytes proofOutput`内部产生多个条目的证明，`bytes proofOutputs`验证者智能合约的责任是确保每个挑战变量是唯一的（即每个`bytes proofOutput`挑战变量包含挑战变量，该挑战变量是前一个条目的挑战变量的散列）。

因此，`bytes proofOutput`由于挑战变量的唯一性，哈希为证明指令创建唯一标识符。

## **在ACE中编目有效的证明**

一旦`BALANCED`，`MINT`或`BURN`证明已得到证实，ACE记录这一事实，使得未来的交易可以查询有问题的证明。这是通过创建以下变量的keccak256哈希（以解压缩的形式编码）来完成的

| 抵消   | 长度   | 名称       | 类型    | 描述                                  |
| ------ | ------ | ---------- | ------- | ------------------------------------- |
| 为0x00 | 为0x20 | proofHash  | bytes32 | 一个keccak256哈希 `bytes proofOutput` |
| 为0x20 | 为0x20 | _证明      | uint24  | 证明的证明                            |
| 0x40的 | 为0x20 | msg.sender | 地址    | 实体呼叫的地址 `ACE`                  |

这将创建一个唯一键，`true`如果证明有效（未存储无效证据），则映射到该键。

合同可以`ACE`与a `bytes proofOutput`一起查询，并与发出指令的实体`uint24 _proof`和a 一起查询`address`。`ACE`可以验证此指令是否来自有效证明。

此机制使智能合约能够代表用户和其他智能合约发布转移指令，从而实现零知识机密dApp。

## **ACE所有者**

应该注意的是，在部署时，ACE的所有者将是一个多签名钱包。

# **的主要责任 ACE**

该`ACE`引擎有两个关键职责：

1. 确定有效AZTEC零知识证明的正确性，并永久记录验证`BALANCED`证据的存在
2. 当提供有效的转移指令时，更新其注释注册表的状态

处理转移指令时，必须满足以下条件：

- 转移指令是否来自票据登记处的所有者？
- 转移指令是否来自*数学上合法的* AZTEC证明？

由于这些双重责任，有效的AZTEC证明*不会*针对特定的票据注册表进行编目。理论上，任何有效证据的输出都可以发给任何注释，注册表。毕竟，有效证据的存在表明所得到的转移指令是平衡的。这是`ACE` *必须*确保所有票据登记处均衡并且没有双重支出的关键财产。

将注释注册表更新限制到给定注释注册表的创建者提供了关注点的自然分离 - `ACE`确定是否*可以*发生传输指令，并且注释注册表所有者确定是否*应该*发生指令。

### **分离证明验证和注释注册表交互**

由于这些双重职责，滚动证明验证和将注册表更新记录到单个函数中似乎是直观的。但是，这会破坏AZTEC协议的关键优势之一 - 第三方dApp可以验证零知识证明，并将生成的转移指令发送到与AZTEC兼容的机密资产。[零知识dApp合同交互，双边交换的示例流程]（＃zero-knowledge-dapp-contract-interaction-an-example-flow-with-Swaps）演示了这种类型的交互，因此，分离的重要性注释注册表更新的证明验证。

# **合同互动**

[![IMG](https://camo.githubusercontent.com/0eb0ad9cc77979d79334e34d3bc678d3b7b6c2a0/68747470733a2f2f626c6f627363646e2e676974626f6f6b2e636f6d2f76302f622f676974626f6f6b2d32383432372e61707073706f742e636f6d2f6f2f6173736574732532462d4c685a6a616f636146333459346a5a674769432532462d4c6d7a4d32575050414f5334794f7569464b692532462d4c6d7a4d74626e756176324f79543859414769253246696d6167652e706e673f616c743d6d6564696126746f6b656e3d66393463656335652d363565652d346634392d616461642d323439633061336136636361)](https://camo.githubusercontent.com/0eb0ad9cc77979d79334e34d3bc678d3b7b6c2a0/68747470733a2f2f626c6f627363646e2e676974626f6f6b2e636f6d2f76302f622f676974626f6f6b2d32383432372e61707073706f742e636f6d2f6f2f6173736574732532462d4c685a6a616f636146333459346a5a674769432532462d4c6d7a4d32575050414f5334794f7569464b692532462d4c6d7a4d74626e756176324f79543859414769253246696d6167652e706e673f616c743d6d6564696126746f6b656e3d66393463656335652d363565652d346634392d616461642d323439633061336136636361)

用户到验证

交易＃1

1. `ACE.validateProof(uint24 _proof, address sender, bytes data)`

2. `Validator.validate(bytes data, address sender, uint[6] commonReferenceString)`（恢复失败，返回`bytes proofOutputs`）

3. 返回`address publicOwner, uint256 transferValue, int256 publicValue`ACE，如果`int256 publicValue`非零，`ACE.transferPublicTokens(address _publicOwner, uint256 _transferValue, int256 _publicValue, bytes32 _proofHash)`（恢复失败）

4. 一个。（如果`proofOutput.publicValue > 0`）`ERC20.transfer(proofOutput.publicOwner, uint256(proofOutput.publicValue))`（恢复失败）

   湾 （如果`proofOutput.publicValue < 0`）`ERC20.transferFrom(proofOutput.publicOwner, this, uint256(-proofOutput.publicValue))`（恢复失败）

5. 返回`bytes proofOutputs`调用者，如果类别，则记录有效证据！= `UTILITY`，恢复失败

[![IMG](https://camo.githubusercontent.com/014ce83b67c8b77d99b5df18ca4752525974513f/68747470733a2f2f626c6f627363646e2e676974626f6f6b2e636f6d2f76302f622f676974626f6f6b2d32383432372e61707073706f742e636f6d2f6f2f6173736574732532462d4c685a6a616f636146333459346a5a674769432532462d4c6d7a4d32575050414f5334794f7569464b692532462d4c6d7a4e32376b436c4646727962594b507a44253246696d6167652e706e673f616c743d6d6564696126746f6b656e3d37313732643066372d303039612d343837612d393964372d363233663762343332326365)](https://camo.githubusercontent.com/014ce83b67c8b77d99b5df18ca4752525974513f/68747470733a2f2f626c6f627363646e2e676974626f6f6b2e636f6d2f76302f622f676974626f6f6b2d32383432372e61707073706f742e636f6d2f6f2f6173736574732532462d4c685a6a616f636146333459346a5a674769432532462d4c6d7a4d32575050414f5334794f7569464b692532462d4c6d7a4e32376b436c4646727962594b507a44253246696d6167652e706e673f616c743d6d6564696126746f6b656e3d37313732643066372d303039612d343837612d393964372d363233663762343332326365)

用户对注册表

交易＃1

1. `ACE.updateNoteRegistry(uint24 _proof, bytes proofOutput, address sender)`

2. `NoteRegistry.validateProofByHash(uint24 _proof, bytes proofOutput, address sender)` （故障时恢复）

   3A。（如果`proofOutput.publicValue > 0`）`ERC20.transfer(proofOutput.publicOwner, uint256(proofOutput.publicValue))`（恢复失败）

   3B。（如果`proofOutput.publicValue < 0`）`ERC20.transferFrom(proofOutput.publicOwner, this, uint256(-proofOutput.publicValue))`（恢复失败）

3. NoteRegistry :(恢复失败）

4. ACE :(恢复失败）

## **零知识dApp合同交互，双边交换的示例流程**

下图描绘了零知识dApp的流程，该dApp利用`Swap`证据向两个zkAsset机密数字资产发出转移指令。此示例旨在说明AZTEC可能实现的机密跨资产交互。该协议的后续迭代将包括支持类似多边流动的证据。

对于两者而言`zkAsset A`，dApp-to-zkAsset交互是相同的`zkAsset B`。为了简化描述，我们仅描述这两个资产之一的交互。

[![IMG](https://camo.githubusercontent.com/22d86cfdafeb060320714ca4b833c270c91f0d1a/68747470733a2f2f626c6f627363646e2e676974626f6f6b2e636f6d2f76302f622f676974626f6f6b2d32383432372e61707073706f742e636f6d2f6f2f6173736574732532462d4c685a6a616f636146333459346a5a674769432532462d4c6d7a4d32575050414f5334794f7569464b692532462d4c6d7a4e4446786e6e484d7770494641535338253246696d6167652e706e673f616c743d6d6564696126746f6b656e3d65626663356664642d666133342d343762312d623365662d323665646366623438366664)](https://camo.githubusercontent.com/22d86cfdafeb060320714ca4b833c270c91f0d1a/68747470733a2f2f626c6f627363646e2e676974626f6f6b2e636f6d2f76302f622f676974626f6f6b2d32383432372e61707073706f742e636f6d2f6f2f6173736574732532462d4c685a6a616f636146333459346a5a674769432532462d4c6d7a4d32575050414f5334794f7569464b692532462d4c6d7a4e4446786e6e484d7770494641535338253246696d6167652e706e673f616c743d6d6564696126746f6b656e3d65626663356664642d666133342d343762312d623365662d323665646366623438366664)

ZK-DAPP流

### **（1-5）：验证证明**

1. `zk dApp``Swap`从`caller`（定义`uint24 _proof`和`bytes data`。）接收零知识证明。
2. 该`zk-dApp`合同查询`ACE`，以验证接收证明，通过`ACE.validateProof(_proof, msg.sender, data)`。如果交易`_proof`不支持。`zk-dApp``revert`
3. 收到有效证明后，`ACE`将确定`validator`与之相关的智能合约`_proof`（在本例中`Swap.sol`）。`ACE`然后会打电话`validator.validateProof(data, sender, commonReferenceString)`。如果`_proof`提供的内容未映射到有效的`validator`智能合约，则交易将进行`revert`。
4. 如果证明有效，`validator`合同将返回一个`bytes proofOutputs`对象`ACE`。如果证明无效，交易将会`revert`。
5. 收到有效证书后`bytes proofOutputs`，`ACE`将检查`_proof`以确定证明是否属于该`BALANCED`类别。如果是这样的话，`ACE`会遍历每个`bytes proofOutput`在`bytes proofOutputs`。对于每个`proofOutput`，`bytes32 proofHash`计算。`bytes32 _proofIdentifier = keccak256(abi.encode(_proof, msg.sender, proofHash))`然后计算唯一的证明标识符。这用作记录有效证据存在的密钥 - `validProofs[_proofIdentifier] = true`。

一旦这个已经完成，`ACE`将返回`bytes proofOutputs`到`zk-dApp`。

### **（6-8）：向...发出转移指令 zkAsset A**

在这个阶段，`zk-dApp`是由有效`Swap`证据产生的转移指令，以`bytes proofOutputs`收到的对象的形式`ACE`。

对于`Swap`证明，`2`内部将有条目`proofOutputs`，每个条目映射到两个机密资产之一 - `zkAsset A`和`zkAsset B`。

1. 该`zk-dApp`合约发出传送指令到`zkAsset A`通过`zkAsset.confidentialTransferFrom(_proof, proofOutput)`。
2. 收到后`uint24 _proof, bytes proofOutput`。该`zkAsset A`合同将验证`_proof`是对契约的证明白名单。如果不是这种情况，交易将会`revert`。

`zkAsset A`通过计算`bytes32 proofHash`和查询`ACE`所接收指令的合法性`ACE.validateProofByHash(_proof, proofHash, msg.sender)`。

1. `ACE`查询其`validProofs`映射以确定生成的证据`bytes proofOutput`是否先前已经过验证，并返回一个布尔值，指示是否是这种情况。

如果没有匹配的证据之前通过验证`ACE`，`zkAsset A`将`revert`交易。

### **（9-16）：处理传输指令**

提供`proofOutput`满足平衡关系的有效内容后，`zkAsset A`将验证以下内容：

- 对于每一个输入`note`，是`approved[note.noteHash][msg.sender] == true`？

如果不是这种情况，交易将会`revert`。

1. 如果已经输入所有注释`approved`，`zkAsset A`将指示`ACE`根据`proofOutput`via中的说明更新其注释注册表`ACE.updateNoteRegistry(_proof, proofOutput, msg.sender)`。
2. 收到后`bytes proofOutput`，`ACE`还将验证该`proofOutput`指令来自有效的零知识证明（`revert`如果不是这种情况）。对证明的正确性感到满意后，`ACE`将指示`msg.sender`（`zkAsset A`）拥有的注释注册表来处理传输指令。
3. `NoteRegistry A` 将验证以下是否正确：
4. 对于每一个输入`note`，都`note.noteHash`存在于`registry`？
5. 对于每一个输出`note`，里面`note.noteHash` *都不*存在`registry`？

如果`proofOutput.publicValue > 0`，注册表将调用`erc20.transfer(proofOutput.publicOwner, uint256(proofOutput.publicValue))`。

如果`proofOutput.publicValue < 0`，注册表将调用`erc20.transferFrom(proofOutput.publicOwner, this, uint256(-proofOutput.publicValue))`。

1. 如果生成的传输指令失败，则事务处理`reverted`，否则返回控制权`Note Registry A`

13-15。如果事务成功，则返回控制`ACE`，然后返回`zkAsset A`和`zk-dApp`。

1. 在成功完成机密转移（来自两者`zkAsset A`和`zkAsset B`）后，控制权将返回`caller`。`zk-dApp`根据ERC-1724机密令牌标准，假设将发出相关的转移事件。

## **多边机密交易背后的理由**

上述说明演示了一种实用的机密跨资产结算机制。如果没有`ACE`，机密数字资产只能在验证指令符合其内部机密事务语义之后处理传输指令，该过程需要验证零知识证明。

这将导致在被验证3个不同的零知识证明（每一个由`zk-dApp`，`zkAsset A`，`zkAsset B`）。由于零知识证明验证是机密交易成本的主要贡献因素，因此这对实际的跨资产机密交互造成了严重障碍。

但是，通过订阅`ACE`有效证据的仲裁者，这三个智能合约可以协同工作以处理多边机密转移，只验证了一个零知识证明（这是因为`Swap`证明产生的转移指令导致两个平衡关系虽然`zkAsset A`并且`zkAsset B`不知道这一点（有关证据可能在创建这些合同`ACE` *之后*被添加），但是，`ACE`是否可以作为转让指令是否有效的最终仲裁者。

虽然这种情况可能要求AZTEC兼容的资产“信任”ACE将正确验证证据，但应该强调的是，这`ACE`是一个完全确定的智能合约，其代码完全可供检查。不需要现实世界的信任（例如，神谕或赌注机制）。关于AZTEC机密交易正确性的保证来源于其零知识证明，所有这些都具有完整性，健全性和诚实验证者零知识的特性。

# **验证AZTEC证明**

AZTEC零知识证明可以通过验证`ACE.validateProof(uint24 _proof, address sender, bytes calldata data) external returns (bytes memory proofOutputs)`。

它`bytes data`使用自定义ABI编码，该编码对于AZTEC支持的每个证明都是唯一的。如果合同需要来自证明的数据，则意图是从`bytes proofOutputs`输入数据中提取数据而不是输入数据。

如果`uint8 category`内部`_proof`是类型`BALANCED`，`ACE`则将证明的有效性记录为内部的状态变量`mapping(bytes32 => bool) validatedProofs`。

如果证明无效，则会引发错误。如果证明有效，`bytes proofOutputs`将返回一个变量，描述执行证明时要执行的指令。对于`BALANCED`证明，`bytes proofOutput`内部的每个变量`bytes proofOutputs`都将满足平衡关系。

# **注意注册实现**

## **创建便笺注册表**

在ACE内部创建了一个注释注册表实例`createNoteRegistry(address _linkedTokenAddress, uint256 _scalingFactor, bool _canAdjustSupply, bool _canConvert)`。

该`_canAdjustSupply`标志定义了注释注册表所有者是否通过创建和刻录AZTEC注释来直接修改注释注册表状态。的`_canConvert`标志定义ERC20是否从令牌`_linkedTokenAddress`可以被转换成AZTEC笔记。如果`_canConvert`是`false`，则`_linkedTokenAddress = address(0)`资产是完全私有资产。

对于给定的笔记注册表，只有所有者可以调用`ACE.updateNoteRegistry`，`ACE.mint`或`ACE.burn`。传统上，这被认为是一个`zkAsset`聪明的合同。这允许`zkAsset`合同绝对控制可以使用哪种类型的证据来更新注释注册表，以及可以进行更新的条件（例如，如果需要额外的验证逻辑）。

## **注意注册表变量**

### **bytes32 confidentialTotalMinted**

此变量是AZTEC UTXO注释的keccak256哈希值，用于定义注释注册表直接创建的值的总量。

创建便笺注册表时，此注释将设置为AZTEC UTXO注释，其值为`0`和查看键`1`。

### **bytes32 confidentialTotalBurned**

此变量是AZTEC UTXO注释的kecckak256哈希值，用于定义注释注册表直接刻录的总值。

创建便笺注册表时，此注释将设置为AZTEC UTXO注释，其值为`0`和查看键`1`。

### **uint256 scalingFactor**

如果此注册表允许将AZTEC注释转换为标记，则`scalingFactor`定义AZTEC注释值`1`映射到的标记数。

这是必需的，因为AZTEC音符的最大值大约是`2^26`（它取决于ACE的公共参考字符串） - 将`256`位变量转换为位变量时存在相关的精度损失`26`。

### **uint256 totalSupply**

此变量表示`ACE`对于给定的注释注册表，由于令牌被转换为AZTEC注释而当前驻留在其中的令牌总数。

### **ERC20 linkedToken**

这是注册表链接的ERC20令牌的地址。只能将一个令牌链接到一个地址。

### **canAdjustSupply**

标记确定票据注册表是否具有铸造和燃烧特权。

### **canConvert**

标记确定注释注册表是否具有公共到私有，反之亦然，转换权限

### **totalSupplemented**

由于在尝试将铸造票据转换为公共价值并且ACE没有足够的令牌时转移令牌，因此ACE补充的令牌总数。

## **智能合约实施**

笔记注册表功能由一套智能合约启用。这主要是为了实现可升级性，并且鉴于ACE是不可变的，因此决定将注释注册表分解为它们自己的可升级模块。

尽管被封装在ACE内部，但注释注册表由ZkAssets拥有。应该被允许升级与特定ZkAsset关联的注释注册表的唯一实体是其所有者。

影响所有笔记注册表状态的所有行为的实现应由ACE的所有者控制和审查，并且ZkAsset所有者不应该能够升级到任意实现。

升级模式或任何单独升级本身不应损害ZkAsset与其注释注册表之间的硬链接（即，未经授权的合同或帐户不应通过升级或注册注册表影响注释注册表的状态是可升级的）。

存储在这些注册表中的数据显然非常敏感，而且很有价值。升级应该是罕见的，向后兼容，并且升级不应导致资金变得无法访问，部分或完全不可花费，或以其他方式受到损害。

在可用的各种可升级性模式中，使用由Open Zeppelin开发的非结构化存储代理模式。此模式的基础是分离注释注册表的存储，注释注册表定义了注释注册表的逻辑，行为和方法的有效注释集。有参与此实现四个基本的合同：`Behaviour.sol`，`AdminUpgradeabilityProxy.sol`，`Factory.sol`和`NoteRegistryManager.sol`。

**行为合同 -** **Behaviour.sol**

行为契约定义了方法并包含了注释注册表的逻辑。这个合同是可变的，可升级的合同以及升级注释注册表方法的实现的方法。所有行为合同都必须遵守设定的最低API，以保持与ACE的兼容性：

```
/**  * @title/** * @title NoteRegistryBehaviour interface which defines the base API        which must be implemented for every behaviour contract. * @author AZTEC * @dev This interface will mostly be used by ACE, in order to have an API to        interact with note registries through proxies. * The implementation of all write methods should have an onlyOwner modifier. * * Copyright Spilsbury Holdings Ltd 2019. All rights reserved. **/contract NoteRegistryBehaviour is Ownable, IAZTEC {    using SafeMath for uint256;    bool public isActiveBehaviour;    bool public initialised;    address public dataLocation;    constructor () Ownable() public {        isActiveBehaviour = true;    }    /**        * @dev Initialises the data of a noteRegistry. Should be called exactly once.        *        * @param _newOwner - the address which the initialise call will transfer ownership to        * @param _scalingFactor - defines the number of tokens that an AZTEC note value of 1 maps to.        * @param _canAdjustSupply - whether the noteRegistry can make use of minting and burning        * @param _canConvert - whether the noteRegistry can transfer value from private to public            representation and vice versa    */    function initialise(        address _newOwner,        uint256 _scalingFactor,        bool _canAdjustSupply,        bool _canConvert    ) public;    /**        * @dev Fetches data of the registry        *        * @return scalingFactor - defines the number of tokens that an AZTEC note value of 1 maps to.        * @return confidentialTotalMinted - the hash of the AZTEC note representing the total amount            which has been minted.        * @return confidentialTotalBurned - the hash of the AZTEC note representing the total amount            which has been burned.        * @return canConvert - the boolean whih defines if the noteRegistry can convert between            public and private.        * @return canConvert - the boolean whih defines if the noteRegistry can make use of            minting and burning methods.    */    function getRegistry() public view returns (        uint256 scalingFactor,        bytes32 confidentialTotalMinted,        bytes32 confidentialTotalBurned,        bool canConvert,        bool canAdjustSupply    );    /**        * @dev Enacts the state modifications needed given a successfully validated burn proof        *        * @param _proofOutputs - the output of the burn validator    */    function burn(bytes calldata _proofOutputs) external;    /**        * @dev Enacts the state modifications needed given a successfully validated mint proof        *        * @param _proofOutputs - the output of the mint validator    */    function mint(bytes calldata _proofOutputs) external;    /**        * @dev Enacts the state modifications needed given the output of a successfully validated proof.        * The _proofId param is used by the behaviour contract to (if needed) restrict the versions of proofs        * which the note registry supports, useful in case the proofOutputs schema changes for example.        *        * @param _proof - the id of the proof        * @param _proofOutput - the output of the proof validator        *        * @return publicOwner - the non-ACE party involved in this transaction. Either current or desired        *   owner of public tokens        * @return transferValue - the total public token value to transfer. Seperate value to abstract        *   away scaling factors in first version of AZTEC        * @return publicValue - the kPublic value to be used in zero-knowledge proofs    */    function updateNoteRegistry(        uint24 _proof,        bytes memory _proofOutput    ) public returns (        address publicOwner,        uint256 transferValue,        int256 publicValue    );    /**        * @dev Sets confidentialTotalMinted to a new value. The value must be the hash of a note;        *        * @param _newTotalNoteHash - the hash of the note representing the total minted value for an asset.    */    function setConfidentialTotalMinted(bytes32 _newTotalNoteHash) internal returns (bytes32);    /**        * @dev Sets confidentialTotalBurned to a new value. The value must be the hash of a note;        *        * @param _newTotalNoteHash - the hash of the note representing the total burned value for an asset.    */    function setConfidentialTotalBurned(bytes32 _newTotalNoteHash) internal returns (bytes32);    /**        * @dev Gets a defined note from the note registry, and returns the deconstructed object.            This is to avoid the interface to be        * _too_ opninated on types, even though it does require any subsequent note type to have            (or be able to mock) the return fields.        *        * @param _noteHash - the hash of the note being fetched        *        * @return status - whether a note has been spent or not        * @return createdOn - timestamp of the creation time of the note        * @return destroyedOn - timestamp of the time the note was destroyed (if it has been destroyed, 0 otherwise)        * @return noteOwner - address of the stored owner of the note    */    function getNote(bytes32 _noteHash) public view returns (        uint8 status,        uint40 createdOn,        uint40 destroyedOn,        address noteOwner    );    /**        * @dev Internal function to update the noteRegistry given a bytes array.        *        * @param _inputNotes - a bytes array containing notes    */    function updateInputNotes(bytes memory _inputNotes) internal;    /**        * @dev Internal function to update the noteRegistry given a bytes array.        *        * @param _outputNotes - a bytes array containing notes    */    function updateOutputNotes(bytes memory _outputNotes) internal;    /**        * @dev Internal function to create a new note object.        *        * @param _noteHash - the noteHash        * @param _noteOwner - the address of the owner of the note    */    function createNote(bytes32 _noteHash, address _noteOwner) internal;    /**        * @dev Internal function to delete a note object.        *        * @param _noteHash - the noteHash        * @param _noteOwner - the address of the owner of the note    */    function deleteNote(bytes32 _noteHash, address _noteOwner) internal;} 
```

**存储/代理合同 -** **AdminUpgradeabilityProxy.sol**

存储合同称为代理，它有四个主要职责：

- 存储定义未使用笔记集的存储变量
- 通过实现对行为合同的调用委托`delegatecall()`。通过这种方式，行为合同上的注释注册表功能在调用代理存储协定的上下文中执行 - 允许行为方法访问注释
- 将代理指向升级的行为实现。此功能受授权机制保护
- 设法改变管理员

界面定义为：

```
/** * @title ProxyAdmin * @dev Minimal interface for the proxy contract to be used by the Factory contract. */contract ProxyAdmin {    function admin() external returns (address);    function upgradeTo(address _newImplementation) external;    function changeAdmin(address _newAdmin) external;}
```

为了便于将行为合同升级到新实例的过程，还有两类合同：工厂合同和票据注册管理器。

**工厂合同 -** **Factory.sol**

工厂合同用于部署升级的行为实例并将其链接到ACE。它们归ACE所有，并且可以部署每种类型的行为实例的工厂合同：可调整和混合。

```
/**  * @title/** * @title NoteRegistryFactory * @author AZTEC * @dev Interface definition for factories. Factory contracts have the responsibility of managing the full lifecycle of * Behaviour contracts, from deploy to eventual upgrade. They are owned by ACE, and all methods should only be callable * by ACE. **/contract NoteRegistryFactory is IAZTEC, Ownable  {    event NoteRegistryDeployed(address behaviourContract);    constructor(address _aceAddress) public Ownable() {        transferOwnership(_aceAddress);    }    function deployNewBehaviourInstance() public returns (address);    function handoverBehaviour(address _proxy, address _newImplementation, address _newProxyAdmin) public onlyOwner {        require(ProxyAdmin(_proxy).admin() == address(this), "this is not the admin of the proxy");        ProxyAdmin(_proxy).upgradeTo(_newImplementation);        ProxyAdmin(_proxy).changeAdmin(_newProxyAdmin);    }} }
```

详细说明用于跟踪各种工厂版本的版本控制系统非常重要 - 每个工厂都与唯一的ID相关联。此标识的目的是标识工厂的以下属性以及生成的已部署行为合同：

- Epoch - 版本号
- Cryptosystem - 注释注册表与之连接的加密系统
- 资产类型 - 票据注册表所属的资产类型，即可转换，可调整，这些的各种组合

这些变量中的每一个`uint8`都用a表示，然后将它们打包在一起`uint24`以提供唯一的工厂ID。Epoch编号只能增加，所有新部署的行为必须向后兼容。

**注意注册表管理器 -** **NoteRegistryManager.sol**

Notes注册表管理器由ACE继承。其职责包括：

- 定义用于部署和升级注册表的方法
- 定义用于实现注册表所有者发送的状态更改的方法
- 管理可用的工厂列表

下面提供了该架构的概述：

[![IMG](https://camo.githubusercontent.com/cc635e34d1385c25be6f5cead4e75905dfd20487/68747470733a2f2f626c6f627363646e2e676974626f6f6b2e636f6d2f76302f622f676974626f6f6b2d32383432372e61707073706f742e636f6d2f6f2f6173736574732532462d4c685a6a616f636146333459346a5a674769432532462d4c6d7a4d32575050414f5334794f7569464b692532462d4c6d7a5043613636555157334b48726371756f253246696d6167652e706e673f616c743d6d6564696126746f6b656e3d35373263323635632d623635372d346530312d616561662d616439393638373836363037)](https://camo.githubusercontent.com/cc635e34d1385c25be6f5cead4e75905dfd20487/68747470733a2f2f626c6f627363646e2e676974626f6f6b2e636f6d2f76302f622f676974626f6f6b2d32383432372e61707073706f742e636f6d2f6f2f6173736574732532462d4c685a6a616f636146333459346a5a674769432532462d4c6d7a4d32575050414f5334794f7569464b692532462d4c6d7a5043613636555157334b48726371756f253246696d6167652e706e673f616c743d6d6564696126746f6b656e3d35373263323635632d623635372d346530312d616561662d616439393638373836363037)

笔记注册表建筑学的例证

## **可升级功能**

上述智能合约系统可用于部署不可升级和可升级的`zkAssets`。只有拥有的`ZkAsset`s才能通过此升级模式进行升级，如果没有所有者，则会部署最新的note注册表行为。

**部署新的不可升级的ZkAsset**

1. 用户部署ZkAsset契约，提供构造函数参数`aceAddress, erc20Address, ERC20_SCALING_FACTOR, canAdjustSupply`。
2. ZkAsset调用ACE，告诉它实例化一个笔记注册表
3. ACE通过NoteRegistryManager找到最新的Factory，并告诉它部署一个新的Proxy合同，然后部署一个新的Behavior合同，在其构造函数中传递Proxy合同的地址。
4. 部署后，Factory将行为的所有权转移到ACE
5. Factory返回新行为合同的地址，ACE添加到从ZkAsset地址到NoteRegistry的映射。

**部署新的NoteRegistry版本**

1. 部署了一个新的Factory.sol，它能够部署新的NoteRegistryBehaviour合同，并且可以管理将所有权从自身转移到它收到的地址
2. ACE的所有者发送一个Tx，将唯一标识符与新工厂的地址相关联

**升级ZkAsset的NoteRegistry**

[![IMG](https://camo.githubusercontent.com/ba04a60607c63081f386e5ee5b6b1e46af7c8d79/68747470733a2f2f626c6f627363646e2e676974626f6f6b2e636f6d2f76302f622f676974626f6f6b2d32383432372e61707073706f742e636f6d2f6f2f6173736574732532462d4c685a6a616f636146333459346a5a674769432532462d4c6d7a4d32575050414f5334794f7569464b692532462d4c6d7a504c34694f6a536a46763149336b7a6e253246696d6167652e706e673f616c743d6d6564696126746f6b656e3d35366531363638312d363933612d343839612d383937622d623666323237326131373638)](https://camo.githubusercontent.com/ba04a60607c63081f386e5ee5b6b1e46af7c8d79/68747470733a2f2f626c6f627363646e2e676974626f6f6b2e636f6d2f76302f622f676974626f6f6b2d32383432372e61707073706f742e636f6d2f6f2f6173736574732532462d4c685a6a616f636146333459346a5a674769432532462d4c6d7a4d32575050414f5334794f7569464b692532462d4c6d7a504c34694f6a536a46763149336b7a6e253246696d6167652e706e673f616c743d6d6564696126746f6b656e3d35366531363638312d363933612d343839612d383937622d623666323237326131373638)

升级便笺注册表行为所涉及的过程概述

1. ZkAsset的所有者致电升级其NoteRegistry，给出特定工厂的特定唯一ID。
2. ZkAsset调用ACE，告诉它升级其NoteRegistry，并将其传递给特定版本使用。
3. ACE找到NoteRegistry，获取其关联的代理地址，并找到要调用的相关工厂
4. ACE告诉工厂部署一个新的Behavior，传入它收到的代理地址。
5. 工厂部署新的行为合同
6. 部署后，工厂将所有权转移给ACE
7. 已部署行为的地址将发送回ACE，
8. ACE告诉旧工厂放弃对代理合同的控制，转而支持新工厂

# **处理转移指令**

一旦收到证明指令（通过`ACE`或通过第三方验证证明`ACE`，例如通过机密分散交换dApp），就可以通过调用来处理它`ACE.updateNoteRegistry(uint24 _proof, bytes proofOutput, address sender)`。

- 如果`msg.sender`内部没有注册注释注册表`ACE`，则事务将抛出
- 如果证明指令**不是**来自`ACE`验证的证明，则交易将抛出
- 如果`validatedProofs[keccak256(abi.encode(_proof, sender, keccak256(proofOutput)))] == false`，交易将抛出

如果满足上述条件，则将指令传递给`NoteRegistry`以下检查：

- 如果任何注释`proofOutput.inputNotes`没有散列到内部不存在的键`noteRegistry`，则事务将抛出
- 如果`proofOutput.outputNotes`对内部*已*存在的键的哈希值有任何注释`noteRegistry`，则事务将抛出
- 如果`proofOutput.publicValue != 0`且资产不是`mixed`，则交易将抛出

一旦满足这些条件，`proofOutput.inputNotes`就会销毁每个音符，`proofOutput.outputNotes`并创建每个音符。

此外，如果`proofOutput.publicValue < 0`，`linkedToken.transferFrom(proofOutput.publicOwner, this, uint256(-proofOutput.publicValue))`被调用。如果此调用失败，则事务将抛出。如果`proofOutput.publicValue > 0`，`linkedToken.transfer(proofOutput.publicOwner, uint256(proofOutput.publicValue))`将被召唤。如果此调用失败，则事务将抛出。

### **关于ERC20令牌转移的说明**

对于`mixed`资产，如果从AZTEC撤回代币，那么从AZTEC的零知识证明检查的平衡关系中，`ACE`将始终保持足够的平衡，因为创建AZTEC票据的唯一方法是首先存入代币。

对于同样具有`mintable`资产的资产`mixed`，还有数字资产构建者必须实施的其他步骤。如果AZTEC注释直接铸造，然后转换为令牌，`ACE`则没有足够的令牌余额来启动转移。

# **Minting AZTEC笔记**

在某些情况下，数字资产所有者可能希望直接向AZTEC注释。一个例子是机密数字贷款，贷款发起人直接以AZTEC票据的形式创建初始贷款登记。

在创建注释注册表时，注册表所有者可以通过设置`bool _canAdjustSupply`为`true`in 来选择其注册表是否为“mintable” `ACE.createNoteRegistry(address _linkedTokenAddress, uint256 _scalingFactor, bool _canAdjustSupply, bool _canConvert)`。

'mintable'注释注册表可以访问该`ACE.mint(uint24 __proof, bytes _proofData, address _proofSender)`功能。此函数将验证由`__proof, _data, _proofSender`（并声明这是`MINTABLE`证明）定义的证明，然后立即`bytes proofOutput`在由受控制的注释注册表中生成`msg.sender`。

甲`MINTABLE`证明如下定义的标准。note注册表包含一个`bytes32 totalMinted`变量，该变量是AZTEC UTXO注释的哈希值，其中包含注册管理机构所有者创建的AZTEC注释的总值。

一个`MINTABLE`证明将产生一个`proofOutputs`对象，具有两个条目。

- 第一个条目包含旧`confidentialTotalMinted`注释和新`confidentialTotalMinted`值
- 第二个条目包含要铸造的注释列表

如果该`confidentialTotalMinted`值与旧`confidentialTotalMinted`值不匹配`proofOutputs`，则事务将还原。

如果所有检查都通过，相关的AZTEC注释将被添加到注释注册表中。

## **铸币和代币**

如果AZTEC笔记直接铸造成可转换为ERC20代币的资产，则应小心谨慎。可能会在注释上尝试转换，并且有问题的注释注册表的令牌余额不足。在这种情况下，交易将恢复。注释注册管理机构所有者有责任提供`ACE`足够的令牌来启用此类转移，因为它远远超出了加密引擎的范围，无法为任何给定的ERC20令牌请求特权。

这可以通过以下方式执行`ACE.supplementTokens(uint256 _value)`，这将导致`ACE`调用`transferFrom`相关的ERC20令牌，同时使用`msg.sender`作为受让人和笔记注册表所有者。假设有关的私人数字资产具有ERC20铸造特权，如果票据登记处也是可控制的。

# **燃烧AZTEC笔记**

燃烧是以相同的方式制定的，以注意铸造。AZTEC注释的总量由`bytes32 confidentialTotalBurned`变量跟踪。

刻录样张遵循类似的模式 - 更新`totalBurned`变量并销毁指定的AZTEC音符。

应该强调的是，只有在注释注册表上设置了相关权限的注释注册表所有者才能调用`ACE.mint`和`ACE.burn`。

如果ERC20令牌已被转换为随后被烧毁的AZTEC钞票，则所产生的令牌将永久锁定在内部`ACE`并且将无法恢复。注释注册表所有者应注意在刻录注释时需要此行为。

# **与ACE交互：zkAsset**

该`zkAsset.sol`合同是保密的令牌，随后的的实现[EIP-1724标准](https://github.com/ethereum/EIPs/issues/1724)。它被设计为机密数字资产构建者可以遵循的模板，以创建与AZTEC兼容的资产。所有`zkAssets`必须遵循以下最小接口：

```
/** * @title IZkAsset * @author AZTEC * @dev An interface defining the ZkAsset standard  * Copyright Spilsbury Holdings Ltd 2019. All rights reserved. **/contract IZkAsset {    event CreateZkAsset(        address indexed aceAddress,        address indexed linkedTokenAddress,        uint256 scalingFactor,        bool indexed _canAdjustSupply,        bool _canConvert    );    event CreateNoteRegistry(uint256 noteRegistryId);    event CreateNote(address indexed owner, bytes32 indexed noteHash, bytes metadata);    event DestroyNote(address indexed owner, bytes32 indexed noteHash, bytes metadata);    event ConvertTokens(address indexed owner, uint256 value);    event RedeemTokens(address indexed owner, uint256 value);    event UpdateNoteMetaData(address indexed owner, bytes32 indexed noteHash, bytes metadata);        function confidentialApprove(        bytes32 _noteHash,        address _spender,        bool _status,        bytes calldata _signature    ) external;    function confidentialTransferFrom(uint24 _proof, bytes calldata _proofOutput) external;        function confidentialTransfer(bytes memory _proofData, bytes memory _signatures) public;}
```

### **创建机密资产**

一个`zkAsset`合同必须内部实例化一个音符注册表`ACE`通过`ACE.createNoteRegistry`。如果资产是混合的，则`ERC20`必须提供链接令牌的合同地址。

### **发布保密交易：confidentialTransfer（）**

单边价值转移的主要方法是通过`zkAsset.confidentialTransfer(bytes _proofData, bytes _signatures)`。在这种方法中，`joinSplit`AZTEC证明用于实现价值转移。交易的受益人完全由内容定义`bytes _proofData`。

双方`ACE.validateProof(data)`并`ACE.updateNoteRegistry(proofOutput)`必须被调用，`proofOutput`被提取`ACE.validateProof`的返回数据。

### **发布委托机密交易：confidentialTransferFrom（）**

该`confidentialTransferFrom(uint24 __proof, bytes _proofOutput)`方法用于执行委托传输。相反`confidentialTransfer`，`confidentialTransferFrom`可以使用任何支持的证明`ACE`（假设`zkAsset`合同接受此类证据）。

## **应用权限**

`zkAsset`在发生价值转移时，由责任执行所需的权限检查。`confidentialTransfer()`呼叫中使用的权限机制与用于呼叫的权限机制不同`confidentialTransferFrom()`。

该`confidentialTransfer`方法对传输中涉及的`signatures`每个方法采用一组EIP712 ECDSA `inputNote`。然后在方法中验证这些`confidentialTransferInternal()`。

但是，此方法不适用于委派的转移呼叫`confidentialTransferFrom()`。在这种情况下，票据“所有者”可能是智能合约，因此无法创建数字签名。因此，`confidentialTransferFrom()`要使用，`confidentialApprove()`必须在消耗的每个输入音符上调用权限授予功能。

### **confidentialApprove**

该`confidentialApprove(bytes32 _noteHash, address _spender, bool _status, bytes memory _signature)`方法赋予`_spender`地址许可，以使用AZTEC注释，其哈希定义为`_noteHash`，用于零知识证明。

的`_status`布尔值定义是否正在给定的或撤销许可。

该`_signature`变量通过EIP712消息定义ECDSA签名。此签名由`address owner`AZTEC备注批准。

如果`_signature = bytes(0x00)`，那么`msg.sender`预计将`address owner`被批准的AZTEC注释。

此接口旨在促进隐形地址。对于隐形地址，地址不太可能有任何以太坊资金来支付天然气成本，并且需要进行元交易式交易。在这种情况下，`msg.sender`不会映射到注释的所有者，因此使用ECDSA signatue。

对于其他用途，例如智能合约或非隐藏地址，`msg.sender`可以通过发送空签名来发送由正确发送的直接交易。

### **授予注释视图密钥访问权限**

AZTEC注释包含一个`metaData`字段，其说明符合ABI讨论中的说明。该数据字段的主要用途之一是存储加密的查看密钥 - 以允许将注释视图访问授予第三方。该`metaData`记的不存储在存储，而是发出与成功创建一个音符一起事件：

```
emit CreateNote(noteOwner, noteHash, metadata);
```

除了在创建笔记时最初提供加密查看密钥的那些之外，可能希望向各方授予笔记视图密钥访问权限。为方便起见，`ZkAssetBase.sol`有一个`updateNoteMetaData()`方法：

```
/*** @dev Update the metadata of a note that already exists in storage. * @param noteHash - hash of a note, used as a unique identifier for the note* @param metaData - metadata to update the note with*/function updateNoteMetaData(bytes32 noteHash, bytes memory metaData) public {    // Get the note from this assets registry    ( uint8 status, , , address noteOwner ) = ace.getNote(address(this), noteHash);    bytes32 addressID = keccak256(abi.encodePacked(msg.sender, noteHash));    require(        (noteAccess[addressID] >= metaDataTimeLog[noteHash] || noteOwner == msg.sender) && status == 1,        'caller does not have permission to update metaData'    );    // Approve the addresses in the note metaData    approveAddresses(metaData, noteHash);    // Set the metaDataTimeLog to the latest block time    setMetaDataTimeLog(noteHash);    emit UpdateNoteMetaData(noteOwner, noteHash, metaData);}
```

此方法的目的是最终发出一个`UpdateNoteMetaData(noteOwner, noteHash, metaData`更新的新事件`metaData`。 `metaData`更新后的`metaData`内容包含IES加密查看密钥，供所有被授予注释视图访问权限的一方使用。

**应用权限**

对此函数的许可至关重要 - 因为能够调用此函数允许将注释视图访问权限赋予任意地址。为此，有一个`require()`声明强制执行两个有效用户组中的一个正在调用此函数。如果没有，它将恢复。

第一类许可来电者是`noteOwner`。票据所有者应该拥有完整的代理机构，他们可以向他们授予查看密钥访问权限。

第二类许可呼叫者是那些被授予视图密钥访问权限的以太网地址`metaData`。这些地址在以下`approvedAddresses`部分中明确说明`metaData`。

要制定此检查，`addressID`首先计算a - 所讨论的音符的`keccak256`散列`msg.sender`和散列。然后我们使用在以下位置`noteAccess` 声明的映射`ZkAsset`：

```
mapping(bytes32 => uint256) public noteAccess;
```

这是的映射`addressIDs`到一个`uint256`，其中，`uint256`是`block.timestamp`在该特定地址最初通过获得批准的块的`approveAddresses()`。

然后我们将比较 `noteAccess[addressID]`存储的值`metaDataTimeLog[noteHash]`。`metaDataTimeLog`是表单的第二个映射：

```
mapping(bytes32 => uint256) public metaDataTimeLog;
```

这是一个映射 `noteHash`到`block.timestamp`时该方法`setMetaDataTimeLog()`被称为最后。此映射用于跟踪`metaData`上次更新特定音符的时间。

通过检查`noteAccess[addressID] >= metaDataTimeLog[noteHash]`我们满足两个条件。首先，这`msg.sender`是一个先前已经批准的视图访问的地址`metaData`。其次，`msg.sender`仍然可以查看对票据的访问权限，并且此后一直未被撤销（通过`metaData`更新而不包括此以太坊地址作为已批准的地址）。

## **setProofs（）**

应该指出的是，`ZkAssets`哪些是可拥有的并且从`ZkAssetOwnable.sol`合同中继承了“支持证据”的概念。所有者可以选择ZkAsset支持哪些证明并可以与之交互。

这是通过该`setProofs()`功能实现的，仅限于`onlyOwner`：

```
function setProofs(    uint8 _epoch,    uint256 _proofs) external onlyOwner {    proofs[_epoch] = _proofs;}
```

为了使ZkAsset能够监听特定证据并与之交互，必须首先在此功能中注册。

默认情况下，所有`ZkAssetOwnable`合同都`joinSplit`在其构造函数中启用了基本的单边转移证明。

## **ZkAssets的类型**

存在各种类型`zkAssets`，基于标志区分`canAdjustSupply`，`canConvert`以及资产是否可拥有。

`canAdjustSupply`确定资产是否能够`mint`或`burn`同时`canConvert`确定公共ERC20令牌是否可以转换为AZTEC票据，反之亦然。这些标志不会向实例化资产的用户公开，而是硬编码到资产的构造函数中或从现有属性派生。`canAdjustSupply`被硬编码到相关资产的构造函数中，同时`canConvert`源自是否`linkedTokenAddress`在资产的构造函数中设置了。

这些标志产生的合同的属性总结在下表中：

| 合同              | canAdjustSupply | canConvert | 可拥有 |
| ----------------- | --------------- | ---------- | ------ |
| ZkAsset           | ñ               | P          | ñ      |
| ZkAssetAdjustable | ÿ               | P          | ÿ      |
| ZkAssetMintable   | ÿ               | P          | ÿ      |
| ZkAssetBurnable   | ÿ               | P          | ÿ      |
| ZkAssetOwnable    | ñ               | P          | ÿ      |

这里`Y`是肯定的，`N`没有和`P`是可能的（它在初始化程序的决定）。`ZkAssetMintable`只能够薄荷，`ZkAssetBurnable`只能够烧，同时`ZkAssetAdjustable`能够既`mint`和`burn`。

# **证明验证合同**

## **JoinSplit.sol**

该`JoinSplit`合同验证AZTEC加入分裂的证明。需要`inputNotes`从注释注册表中删除一系列，并将一系列`outputNotes`要添加到注释注册表中。此外，`publicValue`可以提供一个整数- 这指定要转换为AZTEC备注表格或AZTEC备注表格的ERC20令牌数量。

ABI `bytes data`如下：

| 抵消                                      | 长度          | 名称               | 类型        | 描述                                |
| ----------------------------------------- | ------------- | ------------------ | ----------- | ----------------------------------- |
| 为0x00                                    | 为0x20        | 米                 | uint256     | 输入票据的数量                      |
| 为0x20                                    | 为0x20        | 挑战               | uint256     | 零知识证明挑战                      |
| 0x40的                                    | 为0x20        | publicOwner        | 地址        | 用于证明的公共令牌的受益人          |
| 0X60                                      | 为0x20        | notesOffset        | uint256     | 相对偏移量 `uint[6][] notes`        |
| 0x80的                                    | 为0x20        | inputOwnerOffset   | uint256     | 相对偏移量 `address[] inputOwners`  |
| 0XA0                                      | 为0x20        | outputOwnersOffset | uint256     | 相对偏移量 `address[] outputOwners` |
| 将0xC0                                    | 为0x20        | notemetaDataOffset | uint256     | 相对偏移量 `bytes[] notemetaData`   |
| 0xe0的                                    | L_notes       | 笔记               | UINT [6] [] | 笔记的零知识证明数据                |
| 0xe0 + L_notes                            | L_inputOwners | inputOwners        | 地址[]      | 输入票据所有者的地址                |
| 0xe0 + L_notes + L_inputOwners            | L_owners      | outputOwners       | 地址[]      | 输出票据所有者的地址                |
| 0xe0 + L_notes + L_inputOwners + L_owners | L_metaData    | notemetaData       | 字节[]      | note metaData，用于事件广播         |

`**uint[6][] notes**`包含内部使用的输入和输出UTXO注释集所需的零知识证明数据`JoinSplit`。ABI编码如下：

| 抵消   | 长度   | 名称     | 类型    | 描述                     |
| ------ | ------ | -------- | ------- | ------------------------ |
| 为0x00 | 为0x20 | 千巴     | uint256 | 笔记价值的盲目形式       |
| 为0x20 | 为0x20 | 一间酒吧 | uint256 | 盲注形式的音符查看键     |
| 0x40的 | 为0x20 | gammaX   | uint256 | UTXO音符点'gamma'的x坐标 |
| 0X60   | 为0x20 | gammaY   | uint256 | UTXO音符点'gamma'的y坐标 |
| 0x80的 | 为0x20 | sigmaX   | uint256 | UTXO音符点'sigma'的x坐标 |
| 0XA0   | 为0x20 | sigmaY   | uint256 | UTXO音符点'sigma'的y坐标 |

在连接拆分证明中使用的公共“值”的数量`publicValue`被定义为数组中`kBar`最后一个条目的值`uint[6][] notes`。该值传统上是空的（最后一个音符没有`kBar`参数），并且该空间被重新用于容纳`publicValue`。

# **Swap.sol**

该`Swap`合同确认的零知识证明，它定义的两交易方，订单之间换文*制造商*和订单*接受者*。

该证明涉及4份AZTEC UTXO笔记，并证明以下内容：

1. `note[0].value = note[2].value`
2. `note[1].value = note[3].value`

在此上下文中，注释解释如下：

- `note[0]`：订单制造商投标说明
- `note[1]`：订单制造商问注意
- `note[2]`：订单接受者请注意
- `note[3]`：订单接收者投标说明

此证明不执行任何授权逻辑 - 交易中涉及的资产智能合约负责执行所需的权限检查。

ABI `bytes data`与`JoinSplit.sol`验证智能合约的ABI编码相同。该`Swap`合同将抛出，如果`n != 4`还是`m != 2`。

验证成功验证后，`bytes proofOutputs`将包含两个条目，并带有以下注释分配：

- `proofOutputs[0].inputNotes = [note[0]]`
- `proofOutputs[0].outputNotes = [note[2]]`
- `proofOutputs[1].inputNotes = [note[3]]`
- `proofOutputs[1].outputNotes = [note[1]]`

即无论是为了制造商和订单员正在破坏他们的*投标*注意事项，以换取他们的创造*问*笔记。

内部的每个条目`proofOutputs`定义了平衡关系。如果`proofOutputs[0]`并且`proofOutputs[1]`被发送到不同的ZKAsset智能合约，则该证明可用于定义AZTEC票据的双边交换，在两个交易对手之间以及两个资产类别之间。

ABI `bytes data`如下：

| 抵消                                      | 长度          | 名称               | 类型        | 描述                                |
| ----------------------------------------- | ------------- | ------------------ | ----------- | ----------------------------------- |
| 为0x00                                    | 为0x20        | 挑战               | uint256     | 零知识证明挑战                      |
| 为0x20                                    | 为0x20        | notesOffset        | uint256     | 相对偏移量 `uint[6][] notes`        |
| 0x40的                                    | 为0x20        | inputOwnersOffset  | uint256     | 相对偏移量 `address[] inputOwners`  |
| 0X60                                      | 为0x20        | outputOwnersOffset | uint256     | 相对偏移量 `address[] outputOwners` |
| 0x80的                                    | 为0x20        | notemetaDataOffset | uint256     | 相对偏移量 `bytes[] notemetaData`   |
| 0XA0                                      | L_notes       | 笔记               | UINT [6] [] | 笔记的零知识证明数据                |
| 0xe0 + L_notes                            | L_inputOwners | inputOwners        | 地址[]      | 输入票据所有者的地址                |
| 0xa0 + L_notes + L_inputOwners            | L_owners      | outputOwners       | 地址[]      | 输出票据所有者的地址                |
| 0xa0 + L_notes + L_inputOwners + L_owners | L_metaData    | notemetaData       | 字节[]      | note metaData，用于事件广播         |

# **Dividend.sol**

该`Dividend`证明验证了阿兹台克人UTXO注意的是等于第二AZTEC UTXO音符的公共百分比。此证明属于该`UTILITY`类别，因为在隔离中它不描述平衡关系。

该`Dividend`证据涉及三个AZTEC笔记和两个标量`za, zb`。标量`za, zb`定义了一个比例，证明证明了以下内容：

- `note[1].value * za = note[2].value * zb + note[3].value`

在这种情况下，`note[3]`是一个**剩余的**注释。需要剩余注释以适应舍入误差。考虑用户计算`za, zb`由智能合约固定的价值的利率支付的情景。

在这种情况下，`zb > za`并且`note[1].value`是**源**说明。该**目标**需要注意的是`note[2]`。`note[1]`希望证明这一点的所有者`note[2].value = note[1].value * (za / zb)`，或者尽管他们可以管理给定整数算术的限制。

由于`note[1]`除了票据所有者以外的所有人都不知道它的值，因此他们可以自由选择`note[2]`和的值`note[3]`。但是，为了使价值最大化`note[2]`，最小化的是票据所有者的利益`note[3].value`。

值得强调的是，`Dividend`证据与所有AZTEC证明一样，如果任何票据具有负值，则无法提供令人满意的证据。

在`Dividend`智能合约中使用证据时，应注意确定证据是否被用于验证*借记*计算或*信用*计算，因为确保证明的发送者被激励以最小化`note[3]`（不要最大化它）。

在一个*借方*计算，音符所有者被证明的AZTEC音符正确地表示的值的转移*从*音符所有者。例如，贷款还款。在这种情况下，*最小化***目标**票据的价值符合票据所有者的利益。设置是很重要`note[1]`的**指标**说明，并`note[2]`作为**源**音符。在这种形式下，增加`note[3].value`也会增加目标票据的价值。因此，票据所有者受到激励，以确保`note[3].value`尽可能小。在这种情况下，由于AZTEC范围证明，恶意行为被阻止：`note[3].value`不能是否定的。

在*信用*计算中，激励是相反的，必须设置`note[1]`为**源**注释，并`note[2]`作为**目标**注释。

与`Swap`此类似，此证明不执行许可检查。智能合约的责任是`Dividend`在证据中使用的注释充满意义，并确保观察到正确的许可流程。

ABI `bytes data`如下：

| 抵消                                           | 长度           | 名称               | 类型        | 描述                               |
| ---------------------------------------------- | -------------- | ------------------ | ----------- | ---------------------------------- |
| 为0x00                                         | 为0x20         | 挑战               | uint256     | 零知识证明挑战                     |
| 为0x20                                         | 为0x20         | ZA                 | uint256     | 股息计算标量                       |
| 0x40的                                         | 为0x20         | ZB                 | uint256     | 股息计算标量                       |
| 0X60                                           | 为0x20         | notesOffset        | uint256     | 相对偏移量`uint[6][] notes`        |
| 0x80的                                         | 为0x20         | inputOwnersOffset  | uint256     | 相对偏移量`address[] inputOwners`  |
| 0XA0                                           | 为0x20         | outputOwnersOffset | uint256     | 相对偏移量`address[] outputOwners` |
| 将0xC0                                         | 为0x20         | notemetaDataOffset | uint256     | 相对偏移量`bytes[] notemetaData`   |
| 0xe0的                                         | L_notes        | 笔记               | UINT [6] [] | 笔记的零知识证明数据               |
| 0xe0 + L_notes                                 | L_inputOwners  | inputOwners        | 地址[]      | 输入票据所有者的地址               |
| 0xe0 + L_notes + L_inputOwners                 | L_outputOwners | outputOwners       | 地址[]      | 输出票据所有者的地址               |
| 0xe0 + L_notes + L_inputOwers + L_outputOwners | L_metaData     | notemetaData       | 字节[]      | note metaData，用于事件广播        |

# **PublicRange.sol**

该`PublicRange`证明在零知识验证了一个AZTEC音符的值大于或等于，或小于或等于公共整数。它属于`UTILITY`证明类别。

证明涉及三个数量：

- `originalNote` =注意我们寻求证明的不平等关系
- `publicComparison`=公共整数，与之`originalNote`进行比较
- `utilityNote` =帮助说明，用于构造适当的证明关系

然后使用这些量构建证明关系：`originalNoteValue = publicComparison + utilityNoteValue`。

此外，`isGreaterOrEqual`还为证明提供了一个布尔值。这用于控制证明是否大于或等于，或小于或等于场景。

如果`isGreaterOrEqual`是真的，则它大于或等于证据`originalNoteValue >= publicComparison`。如果`false`，它是小于或等于证明`originalNoteValue <= publicComparison`。

ABI `bytes data`如下：

| 抵消                                           | 长度           | 名称               | 类型        | 描述                               |
| ---------------------------------------------- | -------------- | ------------------ | ----------- | ---------------------------------- |
| 为0x00                                         | 为0x20         | 挑战               | uint256     | 零知识证明挑战                     |
| 为0x20                                         | 为0x20         | publicComparison   | uint256     | 公共整数音符值与之比较             |
| 0x40的                                         | 为0x20         | notesOffset        | uint256     | 相对偏移量`uint[6][] notes`        |
| 0X60                                           | 为0x20         | inputOwnersOffset  | uint256     | 相对偏移量`address[] inputOwners`  |
| 0x80的                                         | 为0x20         | outputOwnersOffset | uint256     | 相对偏移量`address[] outputOwners` |
| 0XA0                                           | 为0x20         | notemetaDataOffset | uint256     | 相对偏移量`bytes[] notemetaData`   |
| 将0xC0                                         | L_notes        | 笔记               | UINT [6] [] | 笔记的零知识证明数据               |
| 0xc0 + L_notes                                 | L_inputOwners  | inputOwners        | 地址[]      | 输入票据所有者的地址               |
| 0xc0 + L_notes + L_inputOwners                 | L_outputOwners | outputOwners       | 地址[]      | 输出票据所有者的地址               |
| 0xc0 + L_notes + L_inputOwers + L_outputOwners | L_metaData     | notemetaData       | 字节[]      | note metaData，用于事件广播        |

# **PrivateRange.sol**

该`PrivateRange`证明在零知识中验证了一个AZTEC音符的值大于或小于第二个AZTEC音符的值。它属于`UTILITY`证明类别，因为没有满足真正的平衡关系。

证据涉及三个AZTEC说明：

- `originalNote` =注意我们寻求证明的不平等关系
- `comparisonNote` =注意与之比较
- `utilityNote` =帮助说明，用于构造适当的证明关系

这些注释用于构建以下证明关系： `originalNote.value = comparisonNote.value + utilityNote.value`

如果满足，则意味着`originalNote.value > comparisonNote.value`。请注意，范围证明意味着无法构造值小于零的注释。为了构造小于证明（即`originalNote.value < comparisonNote.value`），用户必须更改输入顺序以显示该输入顺序`comparisonNote.value > originalNote.value`

`proofOutputs`返回的对象包含一个`proofOutput`对象。将`inputNotes`对应于`originalNote`和`comparisonNote`，与`outputNotes`对应于`utilityNote`。输出音符没有物理意义，用于构建数学上合适的证明关系。

ABI `bytes data`如下：

| 抵消                                           | 长度           | 名称               | 类型        | 描述                               |
| ---------------------------------------------- | -------------- | ------------------ | ----------- | ---------------------------------- |
| 为0x00                                         | 为0x20         | 挑战               | uint256     | 零知识证明挑战                     |
| 为0x20                                         | 为0x20         | notesOffset        | uint256     | 相对偏移量`uint[6][] notes`        |
| 0x40的                                         | 为0x20         | inputOwnersOffset  | uint256     | 相对偏移量`address[] inputOwners`  |
| 0X60                                           | 为0x20         | outputOwnersOffset | uint256     | 相对偏移量`address[] outputOwners` |
| 0x80的                                         | 为0x20         | notemetaDataOffset | uint256     | 相对偏移量`bytes[] notemetaData`   |
| 0XA0                                           | L_notes        | 笔记               | UINT [6] [] | 笔记的零知识证明数据               |
| 0xa0 + L_notes                                 | L_inputOwners  | inputOwners        | 地址[]      | 输入票据所有者的地址               |
| 0xa0 + L_notes + L_inputOwners                 | L_outputOwners | outputOwners       | 地址[]      | 输出票据所有者的地址               |
| 0xa0 + L_notes + L_inputOwers + L_outputOwners | L_metaData     | notemetaData       | 字节[]      | note metaData，用于事件广播        |

# **JoinSplitFluid.sol**

该`JoinSplitFluid`合同能够证明要验证直接铸币或燃烧的AZTEC笔记，如果`Registry.adjustSupply = true`。

薄荷和刻录证明都是证明的特殊情况`joinSplit`- 它们是`joinSplit`证明，但它们具有受限制的指定输入集。此验证器合同用于验证`mint`和`burn`证明。

在`mint`证明中，笔记正在直接创建并添加到笔记注册表中，而`burn`校样笔记正从笔记注册表中删除。在注释方面，`joinSplitFluid`验证器需要三个输入：

- `currentCounterNote` - 请注意，此注释中描述了现有的总铸造/燃烧值
- `newCounterNote` - 请注意，一旦验证了证据并生成结果，就会在此笔记注册表中描述新的总铸造/燃烧值
- `minted/burned notes` - 要在注释注册表中创建和创建的注释，或者从注释注册表中刻录和删除的注释

该`minted/burned`票据被添加或从音符注册表中删除的音符。反票据的目的是跟踪本票据登记处中已铸造或燃烧的总价值 - 该信息可能用于会计目的或审计。

重要的是要注意，对于给定的笔记注册表，只有注册管理机构所有者可以调用`ACE.mint`或`ACE.burn`。只有注册管理机构所有者必须知道总笔记的值 - 这些笔记的哈希值由注册表变量`confidentialTotalMinted`和`confidentialTotalBurned.`

ABI编码`bytes data`与AZTEC `JoinSplit`交易的编码相同。还有就是加限制，即`m = 1`和`n >= 2`。

编码时`bytes proofOutputs`，使用输入`notes`和注释之间的以下映射`proofOutputs`：

- `proofOutputs.length = 2`
- `proofOutputs[0].inputNotes = [currentCounterNote]`
- `proofOutputs[0].outputNotes = [newCounterNote]`
- `proofOutputs[0].publicOwner = address(0)`
- `proofOutputs[0].publicValue = 0`
- `proofOutputs[1].inputNotes = []`
- `proofOutputs[1].outputNotes = [minted/burned notes]`

ABI `bytes data`如下：

| 抵消                                           | 长度           | 名称               | 类型        | 描述                               |
| ---------------------------------------------- | -------------- | ------------------ | ----------- | ---------------------------------- |
| 为0x00                                         | 为0x20         | 挑战               | uint256     | 零知识证明挑战                     |
| 为0x20                                         | 为0x20         | notesOffset        | uint256     | 相对偏移量`uint[6][] notes`        |
| 0x40的                                         | 为0x20         | inputOwnersOffset  | uint256     | 相对偏移量`address[] inputOwners`  |
| 0X60                                           | 为0x20         | outputOwnersOffset | uint256     | 相对偏移量`address[] outputOwners` |
| 0x80的                                         | 为0x20         | notemetaDataOffset | uint256     | 相对偏移量`bytes[] notemetaData`   |
| 0XA0                                           | L_notes        | 笔记               | UINT [6] [] | 笔记的零知识证明数据               |
| 0xa0 + L_notes                                 | L_inputOwners  | inputOwners        | 地址[]      | 输入票据所有者的地址               |
| 0xa0 + L_notes + L_inputOwners                 | L_outputOwners | outputOwners       | 地址[]      | 输出票据所有者的地址               |
| 0xa0 + L_notes + L_inputOwers + L_outputOwners | L_metaData     | notemetaData       | 字节[]      | note metaData，用于事件广播        |

# **实用程序库的规范**

由于AZTEC证明的复杂ABI编码，有必要定义实用程序库，从数字资产构建器中抽象出这种复杂性。

## **NoteUtils.sol**

该`NoteUtils`库提供了帮助方法，可以从中提取数据`bytes memory proofOutputs`。

### **NoteUtils.getLength(bytes memory proofOutputsOrNotes) internal pure returns (uint256 length)**

当提供AZTEC ABI编码的数组（任何一个`bytes memory proofOutputs, bytes memory inputNotes, bytes memory outputNotes`）时，此方法将返回条目数。

### **NoteUtils.get(bytes memory proofOutputsOrNotes, uint256 i) internal pure returns (bytes memory out)**

此方法将返回`i`AZTEC ABI编码数组的第n个条目。如果`i`是无效索引，则会引发错误。

### **NoteUtils.extractProofOutput(bytes memory proofOutput) internal pure returns (bytes memory inputNotes, bytes memory outputNotes, address publicOwner, int256 publicValue)**

这种方法将提取成员`bytes proofOutput`。

### **NoteUtils.extractNote(bytes memory note) internal pure returns (address owner, bytes32 noteHash, bytes memory metaData)**

该方法将提取AZTEC ABI编码的音符的组成成员。如里面的注释`proofOutput.inputNotes`和`proofOutput.outputNotes`。

### **NoteUtils.getNoteType(bytes memory note) internal pure returns (uint256 noteType)**

提取注释的“类型”是作为一个单独的方法提供的，因为这是一种罕见的要求，并且其中包含内部`NoteUtils.extractNote`会膨胀该方法所需的堆栈变量数。

此外还有以下自定义实用程序库：

- `ProofUtils.sol`
- `LibEIP712.sol`
- `VersioningUtils.sol`

# **附录**

## **答：防止碰撞和前线运行**

对于任何AZTEC验证智能合约，基础零知识协议必须具有描述协议的完整性，健全性和诚实验证者零知识属性的正式证据。

除此之外，并且在智能合约中忠实地实现协议的逻辑，必须采取措施来防止“证据冲突”，其中`bytes proofOutput`来自证明的指令具有与`bytes proofOutput`来自不同智能合约验证者的指令相同的结构。这是通过将`uint24 _proof`与特定验证智能合约关联的变量集成到`uint256 challenge`每个`bytes proofOutput`条目中包含的变量中来完成的。

其次，必须防止证据的正面运行。这是采取有效的零知识证明的行为，该证据位于事务池内但尚未开采，并且将证据集成到恶意事务中，用于某些与事务发送者不同的目的。这是通过将消息发送者集成到挑战变量中来实现的 - 恶意行为者不可能修改这样的证据以创建他们自己构造的有效证据，除非他们知道证明中使用的秘密证人。

获取`msg.sender`到认证合同是通过这个变量传递来自正在调用该合同的输入参数进行`ACE.sol`。如果未正确完成，则相关资产易受前沿影响。这不会暴露协议的任何安全风险，因为正确使用ACE的资产不会受到错误实施协议的资产的影响。

## **B - 通过AZTEC注释的兴趣流**

考虑一个接受DAI票据的合同（让我们称之为原始票据），并在交换中发行机密贷款票据，其中贷款票据的价值总和等于原始票据的总和（这是执行）。

当以支付利息的形式向合同提供机密DAI的存款（称为利息票据）时，利息票据的价值与始发票据之间的比率被定义。

AZTEC密码引擎支持零知识证明，允许贷款“票据”持有者从利息票据中流出价值。有效打印zkDAI票据，其价值由上述比率和贷款票据的绝对值定义。作为交换，利息票据被销毁。

在这次交易中，重要的是zk-DAI合约不必对zk-Loan合约做出任何假设，或者信任zk-Loan合约逻辑的正确性。

ACE中的零知识证明使得上述交换能够在没有双重支出的情况下发生。上述机制不能用于“打印”总和大于利息票据的zk-DAI票据。`NoteRegistry`并且`ACE`只验证交易的数学正确性 - 贷款票据（以及由此产生的利息支付）是否根据贷款协议的语义正确分配，与确保没有双重支出无关。

# **词汇表**

| 术语     | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| 平衡关系 | AZTEC注释创建/销毁的实例，其中创建的注释的值的总和等于被销毁的注释的值的总和 |
| 混合资产 | 一个零知识的AZTEC资产，既有私人代表（通过AZTEC注释），也有公开代表（通过类似ERC20的代币） |
| 私人资产 | 一个零知识的AZTEC资产，其所有权完全通过AZTEC说明定义，并且没有链接的ERC20令牌。此类资产必须通过`confidentialMint`说明直接创建AZTEC 说明 |

链接到我们关于[Github](https://github.com/AztecProtocol/specification)的规范。

# 概观

Huff专为开发高度优化的算法而设计，其中首选直接操作程序的字节码。

## **Huff是一种特定于域的语言，用于编写高度优化的以太坊虚拟机程序代码，最终编写智能合约。**

Huff可以构建EVM汇编宏 - 可以严格测试和评估的字节码块。宏本身可以由Huff宏组成。

赫夫并没有隐瞒EVM背后的语法糖的运作。事实上，哈夫并没有隐瞒什么。Huff没有变量，而是直接将EVM的程序堆栈暴露给开发人员直接操作。

Huff支持一种模板形式--Huff宏可以接受模板参数，而模板参数又是Huff宏。这允许可自定义的宏，这是循环展开的理想选择。

可以将Huff算法分解为其组成宏并严格遵循，而无需将算法拆分为函数并调用跳转指令。

# **其他资源**

如果您想了解有关Huff的更多信息，请参阅我们的Github [回购](https://github.com/AztecProtocol/huff)或Zac关于[Medium](https://medium.com/aztec-protocol/from-zero-to-nowhere-smart-contract-programming-in-huff-1-2-ba2b6de7fa83)的系列文章。

# Weierstrudel

## **Weierstrudel使用bn254曲线制作零知识密码系统，例如AZTEC协议大大降低成本。**

`weierstrudel` 是一个高度优化的智能合约，在短的Weierstrass 254位Barreto-Naehrig曲线上执行椭圆曲线标量乘法，该曲线以前由ZCash使用，目前可用作以太坊协议中的预编译智能合约。

目前以太坊标量乘法预编译智能合约的天然气计划是`40,000`天然气。当乘以多于一个点时，weierstrudel **比预编译合同更有效**（参见[基准](https://github.com/AztecProtocol/weierstrudel#benchmarks)）。

# **愤怒**

weierstrudel完全用[Huff](https://github.com/AztecProtocol/huff)编写，[Huff](https://github.com/AztecProtocol/huff)是一种低级域特定语言，可编译为以太坊虚拟机操作码。此外，以下技术用于最小化燃气成本：

- 使用GLV技术利用曲线内同态并将“点加倍”操作的数量减少一半。
- 使用Shamir的技巧将多个标量乘法合并到一个算法中，将“点加倍”操作的数量固定为~127
- 对标量乘数使用Windowed-Non-Adjacent-Form表示，将“点加法”操作的数量减少到每点约50个
- 使用bn254曲线的254位场模数与EVM的256字大小之间的差异来推迟模块化减少，直到绝对必要

`weierstrudel` 广泛使用位移操作码，只有在君士坦丁堡硬叉激活后才与以太坊兼容。

# **其他资源**

如果您想了解有关Weierstrudel的更多信息，请参阅我们的Github [repo](https://github.com/AztecProtocol/weierstrudel)或Zac的Medium [文章](https://medium.com/aztec-protocol/huffing-for-crypto-with-weierstrudel-9c9568c06901)。